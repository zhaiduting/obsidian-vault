---
author:
  - zhaiduting@163.com
created: 2025-06-16
tags:
  - 原创
---

将文本文件合成 mp3 音频的同时，还能自动生成歌词。这样就可以导入音乐播放器里面随意跳转播放了！

```shell
#!/bin/bash

# 🧪 Step 0: 生成测试用的带 <mark> 的 SSML 文件（如未存在）
test_file="sample.txt"
if [ ! -f "$test_file" ]; then
cat > "$test_file" <<EOF
<speak>Hello <mark name='timepoint_1'/> Mark. Good to <mark name='timepoint_2'/> see you.</speak>
EOF
  echo "✅ 已生成测试用文本：$test_file"
fi

# Step 1: 获取输入文件名
if [ -z "$1" ]; then
  read -p "请输入要转换的文本文件名: " input_file
else
  input_file="$1"
fi

# Step 2: 检查文件是否存在且非空
if [ ! -f "$input_file" ] || [ ! -s "$input_file" ]; then
  echo "错误：文件不存在或为空: $input_file"
  exit 1
fi

# Step 3: 获取访问令牌
access_token=$(gcloud auth print-access-token 2>/dev/null)
if [ -z "$access_token" ]; then
  echo "错误：无法获取访问令牌，请先运行：gcloud auth login"
  exit 1
fi

# Step 4: 构造请求体
# 直接从文件读取 SSML 内容，并使用 jq 安全地将其嵌入 JSON
ssml_content=$(cat "$input_file")

request_json=$(jq -n --arg ssml_text "$ssml_content" '
{
  "enableTimePointing": ["SSML_MARK"],
  "input": {
    "ssml": $ssml_text
  },
  "voice": {
    "languageCode": "en-GB",
    "name": "en-GB-Standard-A",
    "ssmlGender": "FEMALE"
  },
  "audioConfig": {
    "audioEncoding": "MP3"
  }
}' | tr -d '\n') # 确保输出为单行，避免 curl 传输问题

# Step 5: 文件名定义
response_json="${input_file}.tts.response.json"
audio_base64="${input_file}.tts.audio.b64"
output_mp3="${input_file}.mp3"
output_lrc="${input_file}.lrc"

# Step 6: 发送请求
echo "正在发送请求到 Google Cloud Text-to-Speech API..."
curl -s -X POST \
  -H "Authorization: Bearer $access_token" \
  -H "x-goog-user-project: zdt-tts-try" \
  -H "Content-Type: application/json; charset=utf-8" \
  -d "$request_json" \
  "https://texttospeech.googleapis.com/v1beta1/text:synthesize" \
  -o "$response_json"

# Step 7: 检查响应中是否有 audioContent
audio_content=$(jq -r '.audioContent' "$response_json")
if [ -z "$audio_content" ] || [ "$audio_content" == "null" ]; then
  echo "错误：响应中未包含音频内容（audioContent 为空）。"
  echo "API 响应详情："
  cat "$response_json" # 打印完整的响应 JSON 以便调试
  exit 1
fi

# Step 8: 提取音频并转为 MP3
echo "$audio_content" > "$audio_base64"
base64 -D -i "$audio_base64" -o "$output_mp3"
echo "✅ 成功生成音频文件：$output_mp3"

# Step 9: 生成 LRC 文件
echo "正在生成 .lrc 文件..."
jq -r '.timepoints[] | "\(.timeSeconds) \(.markName)"' "$response_json" | \
awk '{
    time_seconds = $1;
    mark_name = "";
    for (i = 2; i <= NF; i++) {
        mark_name = mark_name " " $i;
    }
    mark_name = substr(mark_name, 2); # Remove leading space

    minutes = int(time_seconds / 60);
    seconds = int(time_seconds % 60); # 使用 % 运算符代替 fmod
    milliseconds = int((time_seconds - int(time_seconds)) * 100); # 提取小数部分并转换为两位毫秒

    printf "[%02d:%02d.%02d]%s\n", minutes, seconds, milliseconds, mark_name;
}' > "$output_lrc"

echo "✅ 成功生成时间标记文件：$output_lrc"

# Step 10: 清理临时文件
rm -f "$response_json" "$audio_base64"
```
