### 定义

对于类型为 `T` 的操作数 `x`，取址操作 `&x` 会生成一个指向 `x` 的指针，该指针的类型为 `*T`

> For an operand `x` of type `T`, the address operation `&x` generates a pointer of type `*T` to `x`.

以上为[官方文档](https://go.dev/ref/spec#Address_operators)给出的定义，较为抽象。将 T 换成一个具体的类型，比如 int 型，举例如下

```go
// 以下展示 & 的用法

x := 42 // 内存中分配一个 int，地址假设为 0xc00011a040
ptr := &x // 取址后 ptr 值为 0xc00011a040
pptr := &ptr // 可再次取址
```

如果将变量的声明与赋值拆开，就是下面这样

```go
// 以下 *int 和 **int 都是指针类型
var x int
var ptr *int
var pptr **int

x = 42
ptr = &x
pptr = &ptr
```

### 可取址的操作数

以下列举的操作数，都可在其前方添加`&`符号进行取址操作：

- 变量，
- 指针解引用（如 `*p`），
- 切片的索引操作（如 `s[i]`），
- 可取址结构体操作数的字段选择器（如 `o.f`），
- 可取址数组的索引操作（如 `a[i]`），
- 复合字面量（如 `MyStruct{}`）

这意味着下面的代码可以正常运行

```go
package main

import "fmt"

type Obj struct{ f int }

func main() {

	// 变量取址
	x := 42
	fmt.Println(&x)

	// 解引取址
	p := &x
	fmt.Println(&*p, &(*p)) // &*p 合法！等价于 p

	// 切片取址
	s := []int{1, 2}
	fmt.Println(&s[1])

	// 字段取址，或称属性取址
	o := Obj{8}
	fmt.Println(&o.f)

	// 以下皆为字面量取址
	fmt.Println(&Obj{9})
	fmt.Println(&[3]int{1, 2, 3})
	fmt.Println(&[]int{1, 2, 3})
	fmt.Println(&map[string]int{"apple": 1, "banana": 2})
}

/* 运行结果类似于下面这样
0xc000010070
0xc000010070 0xc000010070
0xc000010098
0xc000010078
&{9}
&[1 2 3]
&[1 2 3]
&map[apple:1 banana:2]
 */
```

### 不可取址的操作数

对复合字面量可以进行取址操作，但是不可以对基本字面量进行取址操作。以下都是错误的

```go
// invalid operation: cannot take address of ...
&5
&"hello"
&(x + 1)
&(&x)
```
