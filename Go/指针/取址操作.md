### 定义

对于类型为 `T` 的操作数 `x`，取址操作 `&x` 会生成一个指向 `x` 的指针，该指针的类型为 `*T`

> For an operand `x` of type `T`, the address operation `&x` generates a pointer of type `*T` to `x`.

以上为[官方文档](https://go.dev/ref/spec#Address_operators)给出的定义，较为抽象。将 T 换成一个具体的类型，比如 int 型，举例如下

```go
// 以下展示 & 的用法

x := 42 // 内存中分配一个 int，地址假设为 0xc00011a040
ptr := &x // 取址后 ptr 值为 0xc00011a040
pptr := &ptr // 可再次取址
```

如果将变量的声明与赋值拆开，就是下面这样

```go
// 以下 *int 和 **int 都是指针类型
var x int
var ptr *int
var pptr **int

x = 42
ptr = &x
pptr = &ptr
```

### 可取址的操作数

以下列举的操作数，都可在其前方添加`&`符号进行取址操作：

- 变量，
- 指针解引用（如 `*p`），
- 切片的索引操作（如 `s[i]`），
- 可取址结构体操作数的字段选择器（如 `o.f`），
- 可取址数组的索引操作（如 `a[i]`），
- 例外情况：复合字面量（如 `MyStruct{}`）

这意味着下面的代码可以正常运行

```go
package main

import "fmt"

type Obj struct{ f int }

func main() {

	// 变量取址
	x := 42
	fmt.Println(&x)

	// 解引取址
	p := &x
	fmt.Println(&*p, &(*p)) // &*p 合法！等价于 p

	// 切片取址
	s := []int{1, 2}
	fmt.Println(&s[1])

	// 字段取址，或称属性取址
	o := Obj{8}
	fmt.Println(&o.f)

	// 以下皆为字面量取址
	fmt.Println(&Obj{9})
	fmt.Println(&[3]int{1, 2, 3})
	fmt.Println(&[]int{1, 2, 3})
	fmt.Println(&map[string]int{"apple": 1, "banana": 2})
}

/* 运行结果类似于下面这样
0xc000010070
0xc000010070 0xc000010070
0xc000010098
0xc000010078
&{9}
&[1 2 3]
&[1 2 3]
&map[apple:1 banana:2]
 */
```

### 不可取址的操作数

对复合字面量可以进行取址操作，但是不可以对基本字面量进行取址操作。以下都是错误的

```go
// invalid operation: cannot take address of ...
&5
&"hello"
&(x + 1)
&(&x)
```

---

### 关于复合字面量的例外

在 Go 语言中，"addressable" 通常指的是一个在内存中拥有固定地址、可以被安全地引用的值。这包括：

- **变量 (Variables):** 声明的变量在内存中有确定的存储位置。
- **指针间接引用 (Pointer indirections):** 通过指针访问的值是存储在指针指向的内存地址上的。
- **切片索引操作 (Slice indexing operations):** 切片是底层数组的视图，对切片元素进行索引会访问底层数组中可寻址的元素。
- **可寻址的结构体操作数的字段选择器 (Field selector of an addressable struct operand):** 如果结构体本身是可寻址的，那么它的字段也是可寻址的。
- **可寻址的数组的数组索引操作 (Array indexing operation of an addressable array):** 数组在内存中是连续存储的，如果数组本身是可寻址的，那么它的元素也是可寻址的。

#### 复合字面量通常不是直接“addressable”的原因

当你创建一个复合字面量，例如 `T{}` 或 `[]int{1, 2, 3}`，这个值通常是一个**临时创建的、匿名的值**。在没有将其赋值给一个变量之前，它可能只存在于表达式的求值过程中，并没有一个固定的、长期的内存地址。

#### 为什么复合字面量是 `&` 操作符的例外？

Go 语言允许你对复合字面量直接使用 `&` 操作符，这是为了方便地创建指向新创建的、临时值的指针。
**方便地初始化指针类型:** 有些函数或方法需要接收指针类型的参数。使用 `&T{...}` 可以直接创建一个 `T` 类型的值并获取其指针，而无需先声明一个中间变量。
**简洁地创建指向字面量的指针:** 对于像结构体或数组这样的复合类型，直接创建并获取指针往往比先声明变量再取地址更简洁。

#### 复合字面量到底能否取址？

根据 Go 语言的规范，**从语法层面来说，你可以对复合字面量使用取地址操作符 `&`。** 这会创建一个指向该复合字面量所表示的新创建的值的指针。

**关键在于理解“addressable requirement”的上下文。** 文档中列出的“addressable”通常指的是那些在程序执行过程中拥有稳定内存地址的实体。复合字面量在没有被赋值给变量之前，并不符合这个常规的“addressable”定义。

**例外的原因可以理解为：** Go 语言的设计者为了方便某些编程模式，特意允许对复合字面量进行取地址操作，即使它们不满足通常的“addressable”定义。当你使用 `&T{}` 时，Go 编译器会确保在内存中为 `T{}` 表示的值分配空间，并返回该空间的地址。
