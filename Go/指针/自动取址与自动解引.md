### 方法接收者是指针，但你用值调用

以下代码中，方法 Foo 的接收者为指针类型，由于 v 并非指针类型，所以执行`v.Foo()`时，会自动转换为 (&v).Foo()

注意，对于复合字面量不会自动转换。因此`T{}.Foo()`是不会转换成`(&T{}).Foo()`的

```go
package main

import "fmt"

type T struct{}

func (t *T) Foo() { fmt.Println(t) }

func main() {
	var v T
	v.Foo() // 自动转成 (&v).Foo()
}
```

### 方法接收者是值，但你用指针调用

以下`p.Bar()`自动转换为`(*p).Bar()`以满足`Bar()`方法接受者的类型要求

```go
func (t T) Bar() { fmt.Println(t) }
func main() {
	var p *T = &T{}
	p.Bar() // 自动转成 (*p).Bar()
}
```

### 字段访问

以下`p.Name` 会被编译器自动转成 `(*p).Name`

```go
type T struct {
	Name string
}
func (t T) Bar() { fmt.Println(t) }
func main() {
	var p *T = &T{Name: "Go"}
	fmt.Println(p.Name) // 自动解引用为 (*p).Name
}
```

### 自动解引用不适用的场景

#### 函数传参

以下 setToZero(&a) 报错，因为 Go 不会对函数的形参自动解引用

```go
func setToZero(x int) { x = 0 }

func main() {
	var a int = 42
	setToZero(a) // 不会修改 a
	//setToZero(&a) // ❌ 编译错误：类型不匹配
	fmt.Println(a) // 仍然是 42
}
```

同样，以下 setToZero(a) 报错，因为 Go 不会对函数的形参自动取址

```go
func setToZero(x *int) { *x = 0 }

func main() {
	var a int = 42
	//setToZero(a) // ❌ 编译错误：类型不匹配
	setToZero(&a)
	fmt.Println(a) // 输出 0
}
```

### 字面量接收者

以下 T{}.Foo()报错，因为无法获取复合字面量的地址，更谈不上自动取址了。虽然 &T{} 是可取址的，但也仅限于明确使用了 & 符号进行取址操作。

```go
func (t *T) Foo() { fmt.Println(t) }

func main() {
	var v T
	v.Foo()     // 输出 &{}
	(&v).Foo()  // 输出 &{}
	//T{}.Foo() // ❌ 编译错误
}
```

### 总结

| 场景         | 自动行为                                             |
| ------------ | ---------------------------------------------------- |
| **方法调用** | Go 自动补 `&` 或 `*` 以匹配接收者类型                |
| **字段访问** | Go 自动将 `p.Name` 转换为 `(*p).Name`                |
| **接口调用** | 如果类型实现了接口，不管是 `T` 还是 `*T`，都可以传递 |
