fatal error: all goroutines are asleep - deadlock!

```go
package main

import "fmt"

func main() {
	ch := make(chan int)
	ch <- 1
	ch <- 2
	fmt.Println(<-ch)
	fmt.Println(<-ch)
}
```

**`ch := make(chan int)`**: 这行代码创建了一个**无缓冲通道**。无缓冲通道的特点是，发送操作会一直阻塞，直到有对应的接收操作发生；同样，接收操作也会一直阻塞，直到有对应的发送操作发生。

**`ch <- 1`**: 这行代码会尝试向通道 `ch` 发送数据 `1`。由于 `ch` 是无缓冲的，并且当前没有其他的 Goroutine 在等待从 `ch` 接收数据，所以这个发送操作会**永久阻塞**。

因为 `ch <- 1` 已经阻塞了 `main` Goroutine，导致 `ch <- 2` 和 `x, y := <-ch, <-ch` 这些代码永远无法执行到。整个程序进入死锁状态。

### 缓冲解法

将通道改为有缓冲的通道即可解决这个死锁问题，如下所示

```go
// ch := make(chan int)
ch := make(chan int, 2)
```

但是这种解法有个问题，数据的发送次数不能超过缓冲大小，比如下面这样又会死锁

```go
func main() {
	ch := make(chan int, 2)
	ch <- 1
	ch <- 2
	ch <- 3 // 这条已无法缓冲，导致死锁
	// ...
}
```

### 子协程解法

这种解法的特点是将数据的发送逻辑写进一个单独的函数里，然后新开子协程执行这个函数。如下

```go
func main() {
	ch := make(chan int)
	go send(1, ch) // 新开子协程
	go send(2, ch) // 再开一个
	go send(3, ch) // 再开次数不限
	x, y := <-ch, <-ch
	fmt.Println(x, y)
}
func send(i int, ch chan int) {
	ch <- i
}
```

如果想更严格的控制此函数的通道类型（只能发送数据），则可以限制参数为**单通道类型**`chan<- int`，如下所示

```go
func send(i int, ch chan<- int) {
	ch <- i
}
```

将数据的发送过程交于子协程，这可以有效避免主协程的死锁问题。无论发送多少条都不会阻塞主协程，它们只会阻塞在`ch <- i`这行，但这并不会导致整个程序死锁。

注意，**必须在子线程中执行 send 函数**，否则的话 main 函数仍然会出现死锁问题

```go
func main() {
	ch := make(chan int)
	send(1, ch)
	send(2, ch) // 这样不行，仍然死锁
	// ...
}
```

### 执行结果不能确定

多个子协程并发执行的结果具有不确定性，多次执行 main 函数可以验证这一点。
