## 基本定义

`pub` 是 Rust 中的一个“路径门票”声明。它决定了模块树中的一个“项”（Item）是否允许被其定义范围之外的路径所引用。
我们可以从以下三个维度来彻底理解这个定义：

### 1. 它是“路径可见性”，而非“读写权限”

`pub` 并不关心你对数据是读还是写，它只关心**编译器能不能找到这个东西**。

- 如果没有 `pub`，该项在外部路径中就是“隐身”的。
- 如果有了 `pub`，你就像在地图上点亮了一个坐标，允许别人通过 `use` 或绝对路径导航过来。

### 2. 它具有“级联约束性”

`pub` 不是孤立存在的。要让一个东西真正被看到，必须保证从**根节点**到**目标项**的每一级路径都是公开的。

> **公式**：`最终可见性 = min(路径上所有节点的可见性)` 哪怕最末端的函数是 `pub`，只要它所在的模块是私有的，外部依然无法触达。

### 3. 它是“封装”的控制杠杆

`pub` 及其变体（`pub(crate)`, `pub(super)` 等）共同构成了 Rust 的隔离墙。

- **对外（API）**：通过 `pub` 暴露最小必要接口，保持稳定性。
- **对内（实现）**：通过 `pub(crate)` 允许内部组件协作，同时拒绝外部干涉。

---

## 可见性控制

`pub` 语法像是一个带有参数的修饰符，这种形式在 Rust 中被称为**受限可见性（Restricted Visibility）**。

### `pub(arg)` 的所有可选参数

除了 `self` 和 `crate`，其实还有一个非常强大的 `super` 和一个灵活的 `in`：

| **参数**        | **完整写法**   | **含义**                                                        |
| --------------- | -------------- | --------------------------------------------------------------- |
| **`crate`**     | `pub(crate)`   | **全 Crate 可见**。在整个项目（lib 或 bin）内部公开，对外保密。 |
| **`self`**      | `pub(self)`    | **当前模块可见**。等同于普通私有 `mod`。                        |
| **`super`**     | `pub(super)`   | **父模块可见**。只有上一级模块能看到这个东西。                  |
| **`in <path>`** | `pub(in a::b)` | **指定路径可见**。只对某个特定的祖先模块及其子模块公开。        |

### 无参数的 `pub xxx`

这是最高权限，表示“完全公开”。

### 无 `pub` 修饰符的 `xxx`

这是最小权限，完全私有。

---

## 适用范围

**`pub` 家族（可见性修饰符）只能用于“声明型”语句，不能用于“逻辑型”语句。**

在 Rust 中，你可以把代码分为两类：**项（Items）** 和 **语句/表达式（Statements/Expressions）**。

### 1. 哪些东西可以用 `pub`？（项 - Items）

只要是能被“定义”出来、并被其他地方通过路径（如 `a::b::c`）引用的东西，都可以加 `pub`。

- **模块 (mod)**：`pub mod xxx;`
- **函数 (fn)**：`pub fn run() {}`
- **结构体 (struct) 及其字段**：`pub struct User { pub name: String }`
- **枚举 (enum) 及其变体**：`pub enum Color { Red, Green }`（注意：枚举变体默认跟随枚举的可见性）
- **常量 (const)** 与 **静态变量 (static)**：`pub const PI: f64 = 3.14;`
- **特征 (trait)**：`pub trait Drive {}`
- **类型别名 (type)**：`pub type Kilometers = i32;`

### 2. 哪些东西**不能**用 `pub`？

#### ① 局部变量 (`let`)

`let` 定义的是局部变量，它的生命周期仅限于当前的 `{}` 代码块。

- **错误写法**：`pub let x = 5;`
- **原因**：局部变量存储在栈上，函数运行完就没了，不存在被其他模块“引用”的物理基础。

#### ② 流程控制 (`if`, `for`, `match`, `while`)

这些是执行逻辑，不是定义实体。

- **错误写法**：`pub if x > 0 { ... }`
- **原因**：你不能“引用”一个 if 语句，你只能执行它。

#### ③ 函数参数

- **错误写法**：`fn save(pub name: String) {}`
- **原因**：参数的可见性由函数本身决定。

### 3. 特殊案例：结构体字段的“嵌套可见性”

结构体是一个很有趣的例子，因为它的**整体**和**内部成员**可以有不同的权限。

```rust
pub struct CloudConfig {
    pub region: String,           // 全球可见
    pub(crate) api_key: String,   // 仅限本项目内使用
    secret_token: String,         // 仅限当前文件使用（私有）
}
```

这种精细控制是 Rust 实现**封装**的核心手段：你可以公开结构体，但隐藏敏感数据，强制用户通过你提供的 `pub fn`（构造函数或 Getter/Setter）来操作。

### 4. 深度总结：`pub` 的本质是“路径索引”

**`pub` 的本质是：** 告诉编译器，是否允许在 **模块树** 路径中索引到这个条目。

- **Items（项）** 像是在地图上标注的**建筑物**（图书馆、餐厅）。你可以给它们设置准入权限（`pub`）。
- **Expressions（表达式）** 像是建筑物里的**动作**（走路、吃饭）。你没法给一个“走路”的动作设置“准入路径”。

### 5. 易错点拨：`pub` vs `mut`

很多初学者会混淆 `pub` 和 `mut`。

- **`pub`** 解决的是 **“能不能看到”** 的问题（访问权）。
- **`mut`** 解决的是 **“能不能改”** 的问题（修改权）。

即使一个结构体字段是 `pub` 的，如果你拿到的实例不是 `mut` 的，你依然改不了它。
