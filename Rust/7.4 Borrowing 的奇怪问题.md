本文讨论字符串变量被借用时可能会碰到的一些奇怪的问题。

### 位置固定

被借用期间，在内存中的位置不能改变。

```rust
let s = "Hello".to_string();
let borrow_s = &s;
let move_s = s; // error[E0505]: cannot move out of `s` because it is borrowed

println!("{}", borrow_s);
println!("{}", move_s);
```

move_s 试图移动 s，但是 s 已被借用，无法移动，因此报错。如果将 s 的定义改成如下形式则可以消除 E0505 问题：

```rust
let s = "Hello";
```

但此时 `s` 的类型不再是 `String`，而是 **`&str`**（字符串字面量）。执行 `let move_s = s` 时，编译器并没有“移动”所有权，而是直接**复制**（Copy）了一份这个指针。

### 只读借用能重复

以下代码正常运行，说明 s 被 borrow_s 借用后，仍然可以继续被 borrow_s2 借用。

```rust
let s = "Hello".to_string();
let borrow_s = &s;
let borrow_s2 = &s;

println!("{}", borrow_s);
println!("{}", borrow_s2);
```

### 可变借用要独占

Rust 借用检查器（Borrow Checker） 对以下情况都会报错：

- 可变借用一个已被可变借用的变量；
- 可变借用一个已被只读借用的变量。

跑两段代码就可以验证。

#### 验证：&mut 一个已被 &mut 的变量会失败

```rust
let mut s = "Hello".to_string();
let borrow_s = &mut s;

s.push_str("!"); // error[E0499]: cannot borrow `s` as mutable more than once at a time
println!("{}", borrow_s);
```

编译器给出的错误信息大致意思是：同一时间内，同一变量的可变借用不能超过一次。为什么这里会出现多次可变借用？因为：

1. **第一次（显式）：** `let borrow_s = &mut s;` 创建了一个长期的可变借用，并将其绑定到了变量 `borrow_s` 上。
2. **第二次（隐式）：** `s.push_str("!");` 为了执行这个方法，编译器尝试为 `s` 创建一个临时的 `&mut s` 传给方法。

Rust 的核心规则是：**在同一个作用域内，`&mut` 必须是绝对独占的。**

- 如果 `borrow_s` 还在存活（因为它后面还要被 `println!` 使用），它就占据了 `s` 的“独占修改权”。
- 此时 `s.push_str` 跑过来也想要一个 `&mut s`，就像是在已经被人锁住的房间外又想开一把锁。

编译器报错 `cannot borrow s as mutable more than once`，意思就是：**“对不起，`borrow_s` 已经把 `s` 的写权限拿走了，在它还回来之前，你（哪怕是原主人 `s`）都不能再生成新的写权限。”**

#### 验证：&mut 一个已被 & 的变量会失败

错误信息大致意思是：无法「可变借用」一个已被「只读借用」的变量。

```rust
let mut s = "Hello".to_string();
let borrow_s = &s; // 只读借用

s.push_str("!"); // error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
println!("{}", borrow_s);
```

### 借用的归还

将以上代码的 println! 宏提前一行，代码执行正常。因为宏执行完毕后，后续代码已经没有 borrow_s 什么事了，于是借用结束。后面的 `s.push_str("!")` 变成 s 的首次可变借用，代码运行正常。

```rust
let mut s = "Hello".to_string();
let borrow_s = &mut s; // 借用
println!("{}", borrow_s); // 使用并归还
s.push_str("!"); // 合法！
```

### 再加一行

直接在以上代码末尾添加一行重复代码，再次出现可变借用的独占问题

```rust
let mut s = "Hello".to_string();
let borrow_s = &mut s; // 借用
println!("{}", borrow_s); // 使用但不归还
s.push_str("!"); // 再次借用报错 error[E0499]: cannot borrow `s` as mutable more than once at a time
println!("{}", borrow_s); // 使用，归还
```

第一次执行 `println!("{}", borrow_s)` 后并没有归还，因为最后一行代码还会继续使用 `borrow_s`。这将导致 `s.push_str("!")` 变成再次借用，违背可变借用的独占性而报错。
