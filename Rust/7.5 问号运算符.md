出现在表达式后面的「问号运算符」，并非三目运算符，而是**尝试解包或传播错误的流程控制符**。官方名称为 _The try propagation operator_，本文将其简称为「尝试运算符」。

以 `expression?` 为例，它会尝试对 `expression` 的计算结果进行解包：

- **解包成功时**：假设 `expression` 的值为 `Some(x)`，则将其解包为 `x`，程序继续执行。
- **解包失败时**：如果 `expression` 的值为 `None` 或者 `Err(e)`，则立即**中止当前逻辑并提前向函数的调用者返回  `None` 或者 `Err(e)`**。

### 使用前提

尝试运算符的使用条件较为苛刻，如果用错可能会碰到以下 [E0277](rustc%20--explain%20E0277.md) 的报错信息

> error\[E0277]: the `?` operator can only be applied to values that implement `Try`
>
> error\[E0277]: the `?` operator can only be used in a function that returns `Result` or `Option` (or another type that implements `FromResidual`)

也就是说：

- `expression` 必须实现 Try 接口
- 只能在函数内使用
- 函数的返回值类型为 `Result` 或 `Option`（或者是实现了 `FromResidual` 接口的类型）

### 简化代码的示例

以下代码使用 match 匹配栈顶弹出的 a、b 值并处理的逻辑相对复杂

```rust
fn add_last_numbers(stack: &mut Vec<i32>) -> Option<i32> {
    let a = stack.pop();
    let b = stack.pop();

    match (a, b) {
        (Some(x), Some(y)) => Some(x + y),
        _ => None,
    }
}
```

用尝试运算符改写后的等效代码如下

```rust
fn add_last_numbers(stack: &mut Vec<i32>) -> Option<i32> {
    Some(stack.pop()? + stack.pop()?)
}
```

改写后的代码更精简。

### 消除多层嵌套的示例

假设物流详情结构体如下，其中的快递公司名称可能为空。

```rust
struct TrackingInfo {
    carrier_name: Option<String>,
    ...
}
```

现在想要通过客户 id 查询客户的最新订单是哪家快递公司在负责运输，使用 match 模式匹配可能会写出如下所示的 `get_carrier_name` 函数

```rust
// match 匹配层层嵌套，满眼都是 `Some` 和 `None`

fn get_carrier_name(user_id: u32) -> Option<String> {
    match find_user(user_id) {
        Some(user) => match user.last_order() {
            Some(order) => match order.tracking_info() {
                Some(info) => info.carrier_name, // 终于拿到了
                None => None,
            },
            None => None,
        },
        None => None,
    }
}
```

用尝试运算符改写后代码如下

```rust
fn get_carrier_name(user_id: u32) -> Option<String> {
    let user = find_user(user_id)?;          // 找不到用户？闪人
    let order = user.last_order()?;          // 没订单？闪人
    let info = order.tracking_info()?;       // 没物流？闪人

    info.carrier_name                        // 顺利拿到，它是 Option<String>
}
```

改写后的代码非常扁平，消除了层级嵌套的噩梦。

### 链式调用的示例

以上代码甚至可以简化成下面这样

```rust
fn get_carrier_name(user_id: u32) -> Option<String> {
    find_user(user_id)?.last_order()?.tracking_info()?.carrier_name
}
```

这看起来很像 JS

### 使用 as_ref() 的示例

以下 `&optional` 是[借用类型](7%20所有权（Ownership）与移动（Move）语义.md)，执行 `&optional?` 会报错，因为借用类型并没有直接实现 Try 接口。通过 `optional.as_ref()` 可以很方便的解决这个问题。

```rust
fn main() {
	let optional = None;
	check_optional(&optional);
	check_optional2(&optional);

	let optional = Some(Box::new(9000));
	check_optional(&optional);
	check_optional2(&optional);

	fn check_optional(optional: &Option<Box<i32>>) {
	    match optional {
	        Some(p) => println!("has value {p}"),
	        None => println!("has no value"),
	    }
	}

	fn check_optional2(optional: &Option<Box<i32>>) -> Option<()> {
	    let value=optional.as_ref()?; // 关键代码
	    println!("get {value}");
	    Some(())
	}

	// 如果 check_optional2 的参数不使用借用类型，将导致以下代码报错 
	println!("Main 依然拥有: {:?}", optional);
}
```

执行结果如下

```sh
has no value
has value 9000
get 9000
Main 依然拥有: Some(9000)
```
