`mod` 语句就像是“领养证明”。一个 `.rs` 文件如果想成为项目的一部分，必须在它的**父节点**（上层文件）中使用 `mod` 语句声明它。

要在 `src/lib.rs` 中直接引用路径嵌套的 `src/a/b.rs` 文件，我们需要建立一条完整的**模块树（Module Tree）**。

---

### 1. 核心规则：严禁“越级领养”

Rust 不允许 `lib.rs` 直接跳过 `a` 去领养 `b`。

- **错误观念**：在 `lib.rs` 写 `mod a/b;`（这是非法的语法）。
- **正确观念**：`lib.rs` 领养 `a`，然后 `a` 领养 `b`。

---

### 2. 实操步骤：建立 `a/b.rs` 的引用链

为了让结构最现代化，我们采用 **“新版模块风格”**（即：不使用 `mod.rs`）。

#### 第一步：准备文件结构

```
src/
├── lib.rs
├── a.rs           <-- a 的模块声明文件
└── a/             <-- a 的子模块存放文件夹
    └── b.rs       <-- 目标文件
```

#### 第二步：在 `src/a/b.rs` 中写点东西

```rust
// src/a/b.rs
pub fn hello_from_b() {
    println!("我是深藏在 a/b.rs 里的函数！");
}
```

#### 第三步：在 `src/a.rs` 中领养 `b`

这个文件就像一个“中转站”，它告诉编译器：在我的目录下有一个叫 `b` 的文件。

```rust
// src/a.rs
pub mod b; // 领养 b.rs，并将其设为公开
```

#### 第四步：在 `src/lib.rs` 中领养 `a`

这是树的根部，它领养了 `a`，从而间接连通了 `b`。

```rust
// src/lib.rs
pub mod a; // 领养 a.rs

// 现在，你可以通过长路径访问 b 了
// 或者使用 re-export 技巧让它更好用
pub use crate::a::b::hello_from_b;
```

---

### 3. `mod` 语句的三种形态

`mod` 语句根据后面是否带 `{}`，功能完全不同：

1. **`mod xxx;` (外部引用模式)**
   - **含义**：去寻找名为 `xxx.rs` 或 `xxx/mod.rs` 的文件，并将其内容加载到这里。
   - **用途**：拆分文件。

2. **`mod xxx { ... }` (内嵌模式)**
   - **含义**：在当前文件内划出一块名为 `xxx` 的命名空间。
   - **用途**：在同一个文件里组织代码（常用于写单元测试 `mod tests { ... }`）。

3. **`pub mod xxx;`**
   - **含义**：不但领养了它，还允许外界看到它。
   - **注意**：如果只是 `mod xxx;`，那么 `xxx` 只能在当前文件及子模块可见。

---

### 4. 深度解析：为什么不能“直接”引用？

Rust 的这种设计是为了保证**唯一路径**。

如果 `lib.rs` 能够直接引用 `src/a/b.rs`，那么 `a.rs` 也能引用 `src/a/b.rs`。这会导致同一个文件在模块树中出现在两个位置。

- **后果**：该文件里的 `static` 变量会被初始化两次，类型系统会认为 `lib::b::Type` 和 `lib::a::b::Type` 是两个完全不同的类型，导致严重的混乱。

---

### 5. 进阶技巧：如果你真的想在 `lib.rs` 里“一键触达”

虽然 `mod` 必须逐级声明，但你可以通过 **`pub use` (重新导出)** 在 `lib.rs` 里创建一个快捷方式：

```rust
// src/lib.rs
mod a; // 私有领养，不让用户看到 a 文件夹的存在

// 重新导出：把 b 直接挂在 lib 的根目录下
pub use crate::a::b;

// 现在用户（main.rs）可以直接调用：
// weather_cli::b::hello_from_b();
```

---

### 总结

要在 `lib.rs` 引用 `src/a/b.rs`：

1. 在 `lib.rs` 声明 `mod a;`。
2. 在 `src/a.rs` 声明 `mod b;`。
3. 通过 `crate::a::b` 路径进行访问。

**这种“层层递进”的结构虽然初期多写两行代码，但它保证了你的项目结构像一颗健康的树，每一片叶子都有唯一的归属。你现在的 `a/b.rs` 结构搭建好了吗？是否遇到了编译器的 `file not found` 报错？**
