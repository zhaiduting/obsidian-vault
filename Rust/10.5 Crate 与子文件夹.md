在 src/bin/、tests/、examples/ 等文件夹里的每一个 `.rs` 文件，在 Cargo 眼中都是一个独立的、平级的 Crate 树根。如果 .rs 文件是这些文件夹的子文件夹里的文件，怎么处理的？

回答是：**Cargo 的“自动探测”雷达只扫描第一层。一旦进入子文件夹，规则就从“自动变 Crate”退化回了传统的“手动声明模块”。**

---

### 1. 核心法则：第一层是 Crate，深层是 Module

假设你的目录结构如下：

```
tests/
├── integration_a.rs      <-- Cargo：它是 Crate 根！
├── integration_b.rs      <-- Cargo：它也是 Crate 根！
└── common/               <-- 子文件夹
    ├── mod.rs            <-- Cargo：看不见我，我不是 Crate
    └── helpers.rs        <-- Cargo：看不见我，我不是 Crate
```

#### 规则拆解：

1. **第一层文件**：Cargo 自动把它们当作独立的 Crate。你可以直接运行 `cargo test --test integration_a`。
2. **子文件夹内的文件**：Cargo **不会**自动把它们编译成 Crate。它们在编译器眼里只是“一堆碎纸片”，除非你手动把它们拼进某个 Crate 里。

---

### 2. 怎么处理子文件夹里的代码？

如果你在 `common/helpers.rs` 里写了一些通用的测试工具函数，你想在 `integration_a.rs` 里使用它，你需要按照 **Module 的引入规则** 手动建立联系。

#### 步骤 1：在 `integration_a.rs` 中声明模块

你需要告诉编译器：“嘿，去 `common` 文件夹里找找我的子模块。”

```rust
// tests/integration_a.rs

// 声明子模块
mod common;

#[test]
fn test_something() {
    // 调用子模块里的函数
    common::helpers::do_setup();
}
```

#### 步骤 2：建立模块树

按照 Rust 的模块规则（旧版用 `mod.rs`），你需要有一个入口文件。

- **方案 A (旧版/常用)**：在 `tests/common/mod.rs` 中声明并公开 helpers 模块：`pub mod helpers;`

- **方案 B (新版/麻烦、不推荐)**：在 `tests/common/sub/` 里创建同级的 `common.rs` 文件及 `common/` 文件夹。如果不使用 `sub` 文件夹的话 `common.rs` 会被 Cargo 误认作一个 Crate（因为它在第一层）。

在 Rust 社区中，大家达成了一个**默认的共识**：

1. **在 `src/` 里**：拥抱新风格（`module.rs` + `module/` 文件夹）。
2. **在 `tests/` 里**：坚持用 **`common/mod.rs`**。

这是为了在“不被 Cargo 误认为 Crate”和“组织共享代码”之间取得完美的平衡。

> 现在你明白为什么 `common/mod.rs` 虽然看起来“复古”，但在测试环境下却是不可替代的“钉子户”了吗？

---

### 3. 为什么 Cargo 不把深层文件也当成 Crate？

这其实是一个**保护机制**：

1. **避免爆炸**：如果一个项目有 50 个辅助文件，Cargo 要是把它们全编译成 50 个 Crate，你的电脑风扇会直接起飞，编译时间会变得极其漫长。
2. **共享逻辑**：子文件夹存在的唯一目的，通常就是为了存放 **“被多个 Crate 共享的辅助逻辑”**。通过不自动编译它们，Cargo 给了你一个安全的地方来存放这些非入口代码。

---

### 4. 一个特殊的“潜规则”：`common` 文件夹

在 Rust 社区中，有一个约定俗成的习惯：

如果你在 `tests/` 下创建一个名为 **`common/`** 的文件夹（或者名字里包含 `common`），Cargo 甚至会更聪明一点——它在生成文档或进行某些分析时，会有意忽略这些文件夹，因为它知道那里存放的是“脚手架”代码。

---

### 5. 总结：如何识别身份？

你可以通过这个简单的流程图来判断一个文件的身份：

- **文件在 `src/bin/`, `tests/`, `examples/` 的根部吗？**
  - **是** $\rightarrow$ 它是一个 **Crate 根**。
- **文件在它们的子文件夹里吗？**
  - **是** $\rightarrow$ 它只是一个普通的 **Module 文件**，必须被上层文件用 `mod` 关键字手动“领养”才能生效。

---

**这就是为什么你在很多开源项目中会看到 `tests/common/mod.rs` 的原因。现在，你是不是对如何组织那些复杂的集成测试代码有了清晰的思路？要不要试着在你的项目中建立一个这种“共享辅助模块”结构？**
