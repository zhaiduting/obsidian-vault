这是一个非常经典的 Rust 工程实践。我们将创建一个名为 `weather_cli` 的项目，它将是一个**双料项目**，采用**薄二进制模式**，并展示**重新导出**、**新版模块风格**以及**测试共享代码**等技巧。

### 1. 初始化项目

```sh
cargo new weather_cli
cd weather_cli
# 此时默认只有 src/main.rs，我们需要手动将其变为“双料”
touch src/lib.rs
```

---

### 2. 厚逻辑层：`src/lib.rs` (Library Crate)

我们在这里使用新版模块风格：`engine.rs` 文件 + `engine/` 文件夹。

```rust
// src/lib.rs

// 1. 声明子模块
pub mod engine;

// 2. 重新导出 (Re-export)：技巧！
// 让外部用户可以直接使用 weather_cli::run()，而不需要知道内部复杂的路径
pub use crate::engine::core::run;

// 3. Crate 级可见性：仅限本项目内共享，不对最终用户公开
pub(crate) fn internal_logger(msg: &str) {
    println!("[Internal Log]: {}", msg);
}
```

---

### 3. 子模块实现：`src/engine.rs` 与 `src/engine/`

创建 `src/engine.rs`：

```rust
// src/engine.rs
// 声明 parser 模块（对应 src/engine/parser.rs）
pub mod parser;
// 声明 core 模块（对应 src/engine/core.rs）
pub mod core;
```

创建 `src/engine/parser.rs`：

```rust
// src/engine/parser.rs
pub fn parse_input(city: &str) -> String {
    format!("正在查询 {} 的天气...", city)
}
```

创建 `src/engine/core.rs`：

```rust
// src/engine/core.rs
use crate::engine::parser; // 同 Crate 内引用
use crate::internal_logger; // 引用 lib.rs 里的 pub(crate) 函数

pub fn run(city: &str) {
    internal_logger("核心引擎启动");
    let info = parser::parse_input(city);
    println!("天气预报：{}", info);
}
```

---

### 4. 薄二进制入口：`src/main.rs` (Binary Crate)

它的任务非常纯粹：解析参数，调用库，退出。

```rust
// src/main.rs

// 注意：这里用包名 weather_cli 引用，因为 main 和 lib 是不同的 Crate
use weather_cli::run;

fn main() {
    let args: Vec<String> = std::env::args().collect();
    let city = args.get(1).map(|s| s.as_str()).unwrap_or("北京");

    // 调用库暴露的接口
    run(city);
}
```

---

### 5. 集成测试与共享代码：`tests/`

我们要创建一个集成测试，并展示如何使用 `mod.rs` 避开 Cargo 的自动扫描。

创建 `tests/common/mod.rs`（共享辅助逻辑）：

```rust
// tests/common/mod.rs
pub fn setup() {
    // 比如初始化模拟数据
    println!("测试环境初始化...");
}
```

创建 `tests/api_test.rs`（集成测试 Crate）：

```rust
// tests/api_test.rs

// 1. 引用自己的库
use weather_cli::run;

// 2. 手动领养子文件夹里的辅助模块
mod common;

#[test]
fn test_weather_run() {
    common::setup(); // 调用共享代码
    run("上海");
}
```

---

### 6. 项目最终布局图

```
weather_cli/
├── Cargo.toml
├── src/
│   ├── main.rs            <-- Binary Crate (薄外壳)
│   ├── lib.rs             <-- Library Crate (厚逻辑入口)
│   ├── engine.rs          <-- 模块根 (新风格)
│   └── engine/            <-- 模块文件夹
│       ├── core.rs
│       └── parser.rs
└── tests/
    ├── api_test.rs        <-- 集成测试 (独立 Crate)
    └── common/
        └── mod.rs         <-- 共享代码 (不被识别为 Crate)
```

---

### 7. 技巧总结与验证

- **薄二进制**：`main.rs` 只有几行代码，不含业务逻辑。
- **多 Crate 协作**：`main.rs` 和 `api_test.rs` 都作为外部访问者调用 `lib.rs`。
- **路径隔离**：`internal_logger` 是 `pub(crate)`，所以在 `engine/core.rs` 能用，但在 `main.rs` 里调用会报错。
- **测试技巧**：通过 `tests/common/mod.rs` 完美解决了多个测试文件共享代码却不产生额外 Crate 的问题。

**你可以尝试运行 `cargo run -- 广州` 或者 `cargo test`。你会发现整个项目的组织既清晰又符合 Rust 官方的最佳实践。**

这个结构对你来说是否足够清晰？如果你想尝试更进一步，我们可以聊聊如何把这个项目中的某些模块通过 **`pub(super)`** 进一步精细化控制权限。
