目标：**把一群“长得不一样”的东西（比如圆和方块），塞进同一个“规格统一”的盒子里（数组 `Vec`）。**

---

### 1. 结构体定义：Circle 和 Square

在 Rust 里，它们就是普通的结构体。之所以之前没写，是因为它们在逻辑中扮演“具体的角色”：

```rust
struct Circle { radius: f64 }
struct Square { side: f64 }
```

### 2. 什么是 `Draw` (Trait)？

`Trait`（特征）定义了一组**行为**。我们定义一个 `Draw` 特征，规定“只要是能画出来的东西，都必须有 `draw` 这个动作”：

```rust
trait Draw {
    fn draw(&self);
}

// 让圆实现这个特征
impl Draw for Circle {
    fn draw(&self) { println!("画一个半径为 {} 的圆", self.radius); }
}

// 让方块实现这个特征
impl Draw for Square {
    fn draw(&self) { println!("画一个边长为 {} 的方块", self.side); }
}
```

---

### 3. 什么是 `Vec`？

`Vec`（Vector）就是 Rust 里的**动态数组**。

- **限制**：`Vec` 要求里面的所有东西必须是**同一种类型**，且**大小必须固定**。
- **麻烦来了**：`Circle` 结构体只有 1 个数字，`Square` 可能有更多字段。它们在内存里占的大小不一样，`Vec` 不让它们直接待在一起。

---

### 4. 什么是 `dyn Draw`？

- `dyn` 是 **dynamic（动态）** 的缩写。
- `dyn Draw` 代表 **“任何实现了 Draw 特征的某种类型”**。
- **致命问题**：编译器不知道 `dyn Draw` 到底有多大（可能是圆，也可能是方块）。在 Rust 里，这种大小不确定的类型叫 **DST (Unsized Type)**，你不能直接把它们存在变量里。

---

### 5. Box 登场：它是“调解员”

既然 `Vec` 嫌弃 `Circle` 和 `Square` 大小不一，我们也无法直接用 `dyn Draw`，那该怎么办？

**用 `Box` 包起来！**

```rust
fn main() {
    // 这就是一个“多态”容器
    // 虽然圆和方块大小不同，但“指向它们的钥匙（Box）”大小是完全一样的！
    let shapes: Vec<Box<dyn Draw>> = vec![
        Box::new(Circle { radius: 1.5 }),
        Box::new(Square { side: 2.0 }),
    ];

    for shape in shapes {
        shape.draw(); // 自动调用各自的画图逻辑
    }
}
```

---

### 总结：这三个词连起来的意思

1. **`Vec`**：一个整齐的货架。
2. **`Box`**：货架上统一规格的快递盒。
3. **`dyn Draw`**：快递盒里装的东西（不管它是圆还是方，只要能“画”就行）。

**一句话解释：** 因为 `Circle` 和 `Square` 的个体差异太大，我们给它们每人发了一个 **`Box`（仓库钥匙）**。现在 `Vec` 货架上摆放的不再是沉重的圆和方块，而是**一排整齐的钥匙**。

---

### 为什么这个例子重要？

如果你在做一个游戏，屏幕上有子弹、敌人、玩家，它们都是不同的结构体，但都需要“更新位置”和“渲染”。 这时候你就会写出：`let game_objects: Vec<Box<dyn GameObject>> = ...`。

你觉得这种“用钥匙代替实物”来解决大小不一问题的思路，跟你之前理解的 `Box`（把东西放堆上）是不是联系起来了？你想不想亲手运行一下这个完整的“画图”代码看看效果？
