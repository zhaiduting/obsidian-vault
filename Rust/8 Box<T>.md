`Box<T>` 是 Rust 中最简单的**堆内存（Heap）分配方式**。

如果把变量比作物品，普通的变量是放在**口袋里**（栈/Stack），而 `Box` 则是把物品放在**租用的仓库里**（堆/Heap），你手里只拿了一把**仓库钥匙**（指针）。

它主要有以下三个不可替代的用途：

---

### 1. 处理“递归类型”（确定大小）

这是 `Box` 最常见的用途。Rust 需要在编译时知道每个类型占用多少空间。

想象一个“俄罗斯套娃”结构：

```rust
enum List {
    Cons(i32, List), // 错误！List 包含 List，无限循环，编译器不知道它有多大
    Nil,
}
```

编译器会报错，因为这个结构理论上可以无限大。这时候 `Box` 就上场了：

```rust
enum List {
    Cons(i32, Box<List>), // 正确！Box 是一个指针，大小固定
    Nil,
}
```

**为什么要用 Box？** 因为指针的大小是固定的（在 64 位系统上是 8 字节）。不管套娃有多少层，口袋里只放一把固定大小的钥匙。

---

### 2. 转移超大数据的所有权

当你有一个巨大的数组（比如 100MB 的图片数据）：

- **在栈上**：如果你把这个变量传给另一个函数，Rust 可能会在内存中**完整复制**这 100MB，非常慢。
- **使用 Box**：数据存在堆上。当你转移所有权时，Rust 只是**把钥匙（指针）**交给了对方。仓库里的 100MB 动都不动，极其高效。

---

### 3. 实现“对象多态”（Trait Objects）

如果你有一堆不同的结构体（比如 `Circle`, `Square`），它们都实现了 `Draw` trait。你想把它们放进一个数组里：

```rust
// 错误！数组要求每个元素大小一致，但 Circle 和 Square 大小不同
let shapes: Vec<dyn Draw> = vec![...];

// 正确！用 Box 包起来
let shapes: Vec<Box<dyn Draw>> = vec![
    Box::new(Circle { radius: 1.0 }),
    Box::new(Square { side: 2.0 }),
];
```

由于每个元素现在都是 `Box`（也就是一把钥匙），大小整齐划一，数组就能存下了。

本例的完整代码：[8.3 不同对象的数组](8.3%20不同对象的数组.md)

---

### 总结：什么时候该用 Box？

| **场景**                   | **理由**                                       |
| -------------------------- | ---------------------------------------------- |
| **类型定义递归时**         | 必须用 `Box` 打破无限大小的循环。              |
| **数据特别大时**           | 避免在栈上频繁复制大数据，提高性能。           |
| **需要存储多种不同类型时** | 利用 `Box<dyn Trait>` 抹平不同类型的大小差异。 |
