在 Rust 的世界里，虽然 `cargo new` 只会帮你生成最基础的结构，但 Cargo 确实有一套预设的“自动扫描地图”。

### 1. 创建方式

- **`src/main.rs` 和 `src/lib.rs`**：由 `cargo new --bin` 或 `cargo new --lib` **自动创建**。
- **其他文件夹（`bin/`, `tests/`, `examples/`, `benches/`）**：通常需要你**手动创建**。

**只要你按照这个名字命名文件夹**，Cargo 就会立刻“觉醒”，自动识别其中的文件并分配 Crate 身份，无需在 `Cargo.toml` 里写任何配置。

---

### 2. 文件夹与 Crate 的对应关系表

| **文件夹路径**      | **Crate 类型**      | **产出物**     | **功能描述**                                                  |
| ------------------- | ------------------- | -------------- | ------------------------------------------------------------- |
| **`src/bin/*.rs`**  | **Binary Crate**    | 可执行文件     | 存放除了 `main.rs` 以外的辅助工具或次要程序。                 |
| **`tests/*.rs`**    | **Test Crate**      | 测试执行文件   | **集成测试**。从外部视角测试你的库 API。                      |
| **`examples/*.rs`** | **Example Crate**   | 示例可执行文件 | 展示如何使用你的库。用户运行 `cargo run --example <文件名>`。 |
| **`benches/*.rs`**  | **Benchmark Crate** | 性能分析报告   | 存放性能压测代码。运行 `cargo bench` 时触发。                 |

---

### 3. 深度解析：它们各有什么用？

#### ① `src/bin/`：多功能工具箱

如果你正在开发一个 Package，既有一个主程序 `main.rs`，又想顺便提供一个 `backup-tool.rs`：

- 把 `backup-tool.rs` 扔进 `src/bin/`。
- 运行方式：`cargo run --bin backup-tool`。
- **场景**：很多数据库项目会在 `main.rs` 写服务器，在 `src/bin/` 写初始化工具。

#### ② `tests/`：真正的外部黑盒测试

- **特点**：这里的文件**不能访问**你代码里的私有函数。
- **意义**：如果你在 `src/` 里写测试（单元测试），那是“自检”；在 `tests/` 里写，是模拟“用户初次上手”。

#### ③ `examples/`：活的代码文档

- **妙用**：最好的文档就是能跑的代码。
- **特性**：当你运行 `cargo test` 时，Cargo 也会尝试编译 `examples/` 里的代码，确保你的示例代码没有因为版本更新而过期。

#### ④ `benches/`：性能实验室

- **用途**：使用 `criterion` 等库来测试某段算法的耗时。它对 CPU 占用和内存抖动非常敏感。

---

### 4. 验证实验

你可以现在就动手尝试：

1. 在你的项目根目录执行 `mkdir tests`。
2. 在里面新建 `hello_test.rs`，写一个简单的 `#[test]` 函数。
3. 运行 `cargo test`。

你会发现 Cargo **自动**多出了一个名为 `hello_test` 的测试项，而你根本没有修改过 `Cargo.toml`。这就是 Rust **“约定优于配置” (Convention over Configuration)** 的核心思想。

---

### 5. 进阶提示：文件夹也是模块吗？

这是一个容易翻车的地方：

- `src/bin/`、`tests/`、`examples/` 里的 **`.rs` 文件本身就是 Crate 根**。
- 它们**不属于**你的 `lib.rs` 命名空间。
- 如果你想在这些文件夹里写子模块（比如 `tests/common/mod.rs`），Cargo 默认不会把它当成 Crate，这通常用来放测试用的辅助函数。

**到目前为止，我们已经聊完了 Rust 的所有物理结构。你现在对如何组织你的第一个大型 Rust 项目还有什么疑虑吗？或者你想看看如何在 `examples/` 里写一个调用你自己库的代码？**
