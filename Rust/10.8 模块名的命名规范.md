**Rust 编译器（rustc）本身是区分大小写的**，但由于它必须向底层操作系统请求文件，所以行为会随平台而变：

1. **Linux / macOS (现代文件系统)**：
   - **区分大小写**。如果你写 `mod xxx;` 但文件名为 `XXX.rs`，编译器会直接报错：`file not found`。

2. **Windows**：
   - **不区分大小写**。如果你写 `mod xxx;`，而磁盘上只有 `XXX.rs`，编译器通常能成功找到它并编译。

这种平台差异是**跨平台开发中的“深水炸弹”**。

- **场景**：你在 Windows 上开发，写了 `mod weather;` 却把文件存为 `Weather.rs`。在你的机器上一切运行良好。
- **后果**：当你把代码推送到 GitHub，由运行在 Linux 上的 **CI/CD（自动化测试）** 运行编译时，它会立刻报错崩溃。

### Rust 的官方标准：强制小写

为了避免上述尴尬，Rust 社区有一套强制性的**命名规范（Naming Convention）**。

> **模块名必须使用 `snake_case`（蛇形命名法）：全小写，单词间用下划线隔开。**

如果你在 Rust 中定义了一个大写字母开头的模块：

```rust
mod Weather; // 警告：Module names should have a snake_case name
```

即便在 Windows 上能跑通，Rust 编译器（通过 `clippy` 或内置检查）也会给你弹出一堆黄色警告，强迫你改成小写。

### 手动指定路径

如果你发现自己必须处理奇怪的文件命名，可以使用 `#[path]` 属性手动指定路径（但这通常意味着架构设计出了问题）：

```rust
#[path = "MySpecialFile.rs"]
mod xxx; // 把 MySpecialFile.rs 领养为 xxx 模块
```

### 模块冲突

如果你在同一个目录下同时创建了 `xxx.rs` 和 `xxx/mod.rs`，并尝试在父模块中声明 `mod xxx;`，Rust 编译器会陷入一种逻辑上的“主权危机”。

#### 1. 报错原因：歧义性（Ambiguity）

Rust 坚守一个核心原则：**模块路径必须是唯一的。**

当你写下 `mod xxx;` 时，编译器面临两个同样合法的选择：

- 它是**叶子模块**（一个文件 `xxx.rs`）？
- 还是**目录模块**（一个文件夹里的 `xxx/mod.rs`）？

由于编译器无法替你做决定，它会抛出一个名为 `E0761` 的错误，提示如下：

> `error[E0761]: file for module 'xxx' found at both "src/xxx.rs" and "src/xxx/mod.rs"`

---

#### 2. 为什么 Rust 允许这两种写法并存？

这其实是 Rust 模块系统的“新旧更替”留下的痕迹：

- **旧版风格 (`mod.rs`)**：在 Rust 2015 中，如果你想让 `xxx` 拥有子模块，`xxx` 必须是一个文件夹，且入口必须叫 `mod.rs`。这导致编辑器里会排出一排同名的 `mod.rs`，非常难找。
- **新版风格 (`xxx.rs` + `xxx/`)**：在 Rust 2018 之后，你可以直接用 `xxx.rs` 作为入口，同时配套一个同名的 `xxx/` 文件夹存放子模块。

---

#### 3. 如何解决这个冲突？

如果你不小心同时创建了两者，通常的迁移策略是：

1. **如果你想用新风格**：将 `xxx/mod.rs` 的内容移动到 `xxx.rs` 中，然后删除 `mod.rs`。
2. **如果你想用旧风格**：将 `xxx.rs` 的内容移动到 `xxx/mod.rs` 中，然后删除 `xxx.rs`。

---

##### 4. 总结

在 Rust 的模块管理中：

- **同名文件与文件夹入口不能并存**（报错 `E0761`）。
- **新风格（`xxx.rs`）更受欢迎**，因为它避免了项目中出现大量的 `mod.rs`。
