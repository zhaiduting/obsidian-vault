
```rust
// 第一组：Copy 语义
let i = 5;
fn print_int(int: isize) {
    println!("{}", int);
}
print_int(i); // 实际上是：print_int(i.自动复制一份)
println!("{}", i); // i 依然活着，因为原件没动

// 第二组：Move 语义
let s = 5.to_string();
fn print_str(str: String) {
    println!("{}", str);
}
print_str(s); // 发生 Move：s 把堆内存的“钥匙”交给了函数
println!("{}", s); // error[E0382]: borrow of moved value: `s`
```

### 对比表如下

| **特性**       | **isize / i32 (栈数据)** | **String / Vec<T> (堆资源)**   |
| -------------- | ------------------------ | ------------------------------ |
| **特征类型**   | 实现 `Copy` 特征         | 实现 `Drop` 特征               |
| **传参行为**   | **复制 (Copy)**          | **移动 (Move)**                |
| **内存成本**   | 极低（复制几个字节）     | 高（若复制则需重新分配堆空间） |
| **原变量状态** | 保持有效 ✅              | 立即失效 ❌                    |

### 为什么不让 `String` 也自动 Copy？

想象一下，如果 `s` 是一个 1GB 大小的视频文件。如果每传一次函数都“自动复制”一份，你的内存会瞬间爆炸。

Rust 的设计哲学是：

1. **廉价的操作**（如栈复制）可以是隐式的（`Copy`）。
2. **昂贵的操作**（如堆分配）必须是显式的（`.clone()`）。

所以，如果你想让第二条 `println!` 也变好，你必须手动写成： `print_str(s.clone());` —— 这就是在告诉编译器：“我愿意承担性能损失，请给我复制一份所有权。”