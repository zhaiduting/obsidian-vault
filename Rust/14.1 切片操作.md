既然你对底层内存布局已经有了这种“透视感”，那我们就直接切入 Rust 字符串最让人“崩溃”也最安全的地方：**UTF-8 编码与字节索引。**

在 C 语言或 Java 中，你可能会习惯用 `s[0]` 取第一个字符。但在 Rust 中，如果你敢对字符串这么做，编译器会直接**拒绝编译**。

---

### 1. 为什么不能用索引？（字节 vs 字符）

Rust 的 `String` 和 `&str` 内部全是 **UTF-8 编码**的字节序列。

- **英文字符**（如 'A'）：占用 **1 个字节**。
- **中文字符**（如 '你'）：占用 **3 个字节**。
- **表情符号**（如 '🚀'）：占用 **4 个字节**。

如果你有一个字符串 `let s = "你好";`，它的内存长度（`.len()`）是 **6**，而不是 2。

---

### 2. 切片的“地雷”：越界与对齐

你可以对字符串进行切片，比如 `&s[0..3]`。但这就像在雷区走路：

```rust
let s = "你好";

// ✅ 正常：取前 3 个字节，正好是“你”
let you = &s[0..3];
println!("{you}"); // 输出：你

// ❌ 崩溃：取前 2 个字节，但这只是“你”的三分之二！
// let broken = &s[0..2];
// 程序会直接 panic：'byte index 2 is not a char boundary'
```

**结论：** Rust 宁愿让你的程序在运行时崩溃，也不允许你产生一个“无效的 UTF-8 序列”。这种严苛保证了你处理字符串时永远不会出现乱码。

---

### 3. 如何正确地“数”字符？

如果你真的想按顺序处理字符，不能靠索引，得靠**迭代器**：

```rust
let s = "你好";

// 方式 A：按字节迭代 (u8)
for b in s.bytes() {
    println!("{b}"); // 输出 6 个数字（字节码）
}

// 方式 B：按字符迭代 (char)
for c in s.chars() {
    println!("{c}"); // 输出：你，好（Rust 自动帮你处理了多字节逻辑）
}

/* 输出
228
189
160
229
165
189
你
好
*/
```

---

### 4. 总结：Rust 字符串的“三重面相”

当你观察一个字符串时，Rust 提供了三种视角：

1. **字节 (Bytes)**：底层 `[u8]`，最快，但不直观。
2. **标量值 (Chars)**：`char` 类型（固定 4 字节），适合逻辑处理。
3. **字形簇 (Graphemes)**：用户眼中的“一个字符”（比如带音标的字母），需要额外的库才能完美处理。

---

### 最后的“冷知识”

还记得你最早问的 `&'static str` 吗？ 因为它是**只读**的，所以多个变量可以同时指向二进制程序里的同一块地址。即使你定义了 100 个 `let a = "Hello";`，它们在内存里可能只占用一份 `"Hello"` 的空间。这叫 **String Interning（字符串驻留）**，是 Rust 极致节省内存的体现。

**现在你已经掌握了 Rust 字符串的内存架构、所有权转换和编码陷阱。想不想试着写一个函数，接收一个 `String` 并返回它翻转后的结果？（这在 Rust 里可比 Python 难得多哦！）**

下一篇 [14.2 翻转字符串](14.2%20翻转字符串.md)