错误代码如下

```rust
let s = "Hello".to_string();
fn calculate_length(s: String) -> usize {
    s.len()
}
println!("s = {}, length = {}", s, calculate_length(s))
```

报错信息为 `error[E0505]: cannot move out of `s` because it is borrowed`

### 1\. 先了解 println! 宏

`println!` 宏的设计初衷是让你方便地打印数据，而不是让你在打印时丢掉数据的所有权。
`println!` 宏在展开代码时，会自动为参数加上取地址符 `&`。
`println!("{}", s)` 与 `println!("{}", &s)` 实际效果是一样的。

- **当你传 `s` 时：** 宏展开后，它实际上是通过引用来访问 `s` 的。这被称为“自动借用”。
- **当你传 `&s` 时：** 你显式地传递了一个引用。对于 `println!` 来说，它接收到的就是一个引用的引用（`&&String`），而 Rust 的 `Display` 特征（Trait）可以自动处理这种多层引用（解引用强制转换）。

**结论：** 无论你加不加 `&`，`println!` 最终都是在**不获取所有权**的情况下读取数据。

### 2\. 再看 calculate_length 函数

函数 `fn calculate_length(s: String)` 签名的意思是： **“我需要接管这个字符串的所有权”** 。

- 执行 `calculate_length(s)` 时，变量 `s` 的所有权被移动（Move）到了函数内部的形参 `s` 中。
- 当函数执行完毕，函数内部的 `s` 离开作用域，该字符串占用的内存会被立即释放（Drop）。
- 此时，外部作用域的 `s` 已经变成了 **无效的“空壳”** 。

⚠️ 总而言之在 Rust 中，如果你看到一个函数接收 `String` 而不是 `&String` ，请务必警惕—— **这通常意味着调用结束后，原变量就“死”了。**

### 2\. 分析 println! 报错原因

在处理 `println!("...", s, calculate_length(s))` 时，编译器会分析这一行中所有变量的状态：

1. **词法扫描**：编译器扫描这一行，发现 `println!` 宏需要对变量 `s` 进行一次**不可变借用**（为了打印第一个 `{}`）。
2. **划定借用范围**：这个借用的生命周期（Lifetime）必须覆盖整个 `println!` 语句的执行过程。
3. **发现冲突**：在同一个语句中，编译器看到了 `calculate_length(s)`。由于这个函数接收的是 `String`（所有权类型），它要求立即执行 **Move** 操作。
4. **抛出错误**：编译器判定——“在 `s` 被借用的期间，你试图移走它”。这就触发了 `E0505` 错误。

⚠️ 在 Rust 看来，只要一个变量被借用了，它就进入了“冻结”状态。在冻结期间：

- 不能被**修改**（如果是不可变借用）。
- 绝对不能被**移动**（Move）。

### 3\. 如果先移走，后借用会怎样？

```rust
// 原先代码，先借后移
// error[E0505]: cannot move out of `s` because it is borrowed
println!("s = {}, length = {}", s, calculate_length(s))

// 改成下面这样，先移后借
// error[E0382]: borrow of moved value: `s`
println!("length = {}, s = {}", calculate_length(s), s)
```

这个更容易理解：你无法借用一个已被移走的 s

### 4\. 修正方案

如果你既想得到长度，又想在之后继续使用字符串，有三种办法：

#### 方案 A：借用（最推荐）

使用引用 `&String` 或 `&str` 。这是 Rust 的日常操作，像借书看一样，看完还回来。

```rust
fn calculate_length(s: &String) -> usize {
    s.len()
}
// 调用时加 &，表示只借不移
println!("s = {}, length = {}", s, calculate_length(&s));
```

#### 方案 B：克隆（最暴力）

如果你不在乎性能开销，可以送一个副本过去。

```rust
// 送一个分身过去，本体 s 依然安全
println!("s = {}, length = {}", s, calculate_length(s.clone()));
```

#### 方案 C：把所有权还回来（最原始）

函数不仅返回长度，还把字符串原样退回。

```rust
fn calculate_length(s: String) -> (String, usize) {
    let len = s.len();
    (s, len) // 返回一个元组，把所有权还回去
}
```

这是一种相对麻烦的改法，main() 函数也要做相应调整

```rust
fn main() {
    let s = String::from("Hello");

    // 1. 调用函数，s 的所有权移入函数
    // 2. 函数返回一个元组 (String, usize)
    // 3. 通过模式匹配，将所有权重新绑定给新的变量 s（变量遮蔽）
    let (s, len) = calculate_length(s);

    // 现在 s 重新拥有了所有权，可以安全打印
    println!("s = {}, length = {}", s, len);
}
```

### 方案对比

虽然“还回所有权”的方法可行，但在 Rust 中， **90% 的场景下我们都会选择“借用（&String）”** ，因为手动还所有权显得太啰嗦了：

| 方法             | 代码复杂度        | 内存开销      | 推荐度     |
| ---------------- | ----------------- | ------------- | ---------- |
| **元组返回**     | 高 (需要重新绑定) | 低            | ⭐         |
| **克隆 (Clone)** | 低                | 高 (复制内存) | ⭐⭐       |
| **借用 (&)**     | **极低**          | **极低**      | ⭐⭐⭐⭐⭐ |
