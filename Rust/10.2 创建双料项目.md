`cargo new` 是一个“单选”工具。它很固执，要么给你生成 `main.rs`，要么给你生成 `lib.rs`，它不会主动帮你创建“全家桶”结构。

这是因为 Rust 希望你从一开始就明确：这个项目的**核心定位**是什么。

### 1. 如何手动合成“双料”项目？

虽然命令不支持，但**手动合成**只需要 5 秒钟。假设你刚才运行了 `cargo new my_app`（现在你只有 `main.rs`）：

1. 在 `src/` 目录下新建一个文件 `lib.rs`。
2. 在 `lib.rs` 里写你的逻辑（比如 `pub fn add(a: i32, b: i32) -> i32 { a + b }`）。
3. 在 `main.rs` 里通过包名引用它（`use my_app::add;`）。

**现在，你的 Package 就拥有了两个 Crate 根：**

- 一个 **Library Crate** (`src/lib.rs`)
- 一个 **Binary Crate** (`src/main.rs`)

---

### 2. 为什么 Cargo 不提供 `cargo new --both` 这种命令？

这背后其实体现了 Rust 社区的一种**架构审美**：

- **鼓励解耦**：如果命令默认生成两个文件，新手可能会往 `main.rs` 里写业务逻辑，往 `lib.rs` 里也写业务逻辑，导致代码混乱。
- **按需演进**：Rust 认为一个项目通常是从一个“点”开始的。
  - 如果你在写工具，你就从 `main.rs` 开始。
  - 当你发现你的算法写得太好了，想分享给别人或者想写集成测试时，你才会**有意识地**去创建 `lib.rs`。

---

### 3. 一个有趣的“潜规则”

如果你去 GitHub 上看那些流行的 Rust 开源库（比如 `ripgrep` 或 `exa`），你会发现它们几乎全是“双料”甚至“多料”：

- **真正的核心**：全部缩在 `lib.rs`（或者是 Workspace 里的子 Crate）。
- **外壳程序**：`main.rs` 或 `src/bin/*.rs` 往往只有寥寥几行代码，它们只是负责解析一下参数，然后立刻调用 `lib.rs`。

这种结构的好处是：**你的核心代码永远是作为“库”存在的，这让它天生就具备了可测试性和可重用性。**

---

### 4. 总结

`cargo new` 只是给你搭个梯子，至于你是想往上爬（写 Binary）还是横着走（写 Library），梯子搭好后，你想怎么加横梁（添加其他 Crate 根）都是你的自由。

**这就是我们之前聊到的“薄二进制”模式的起点。你现在手头是不是已经有一个创建好的项目了？要不要试着手动把 `lib.rs` 加进去，然后感受一下 `main.rs` 像个陌生人一样通过包名去访问 `lib.rs` 逻辑的过程？**
