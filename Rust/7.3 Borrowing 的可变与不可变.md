```rust
fn print_str(str: &mut String) {
  str.push_str("!");
  println!("{}", str);
}
let mut s = String::from("Hello");

print_str(&mut s); // Hello!
print_str(&mut s); // Hello!!
println!("{}", s); // Hello!!
print_str(&s); // error[E0308]: mismatched types
```

定义 s 的时候已经指定了可变类型 `let mut s`，为什么调用 print_str 的时候仍要加上 mut 呢？

Rust 的设计原则是**显式优于隐式**。

- **`let mut s`**：这表示 `s` 这个“柜子”允许被修改。
- **`&s`（不可变借用）**：你只给了函数一把“只读钥匙”。即使柜子本身可以改，但只要你给的是只读钥匙，函数就不能动它。
- **`&mut s`（可变借用）**：你给了函数一把可读可写的“管理员钥匙”。

如果你在调用时只写 `print_str(&s)`，Rust 编译器会认为你只想让函数“看看”字符串，但你的函数签名 `fn print_str(str: &mut String)` 却要求必须拿“管理员钥匙”才能运行。**类型不匹配**由此产生。
