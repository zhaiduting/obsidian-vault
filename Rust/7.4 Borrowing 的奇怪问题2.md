r 借用 s，然后改变 r，期望通过修改 r 达到修改 s 的目的。这在其他语言里很简单，但是在 Rust 里却变得非常复杂。

## 示例

下面的写法会报错，因为 r 已经被推断为指向可变字符串的指针类型（&mut String），而赋值语句却给它提供了一个字符串，类型不符。

```rust
fn main() {
    let mut s = String::from("hello");
    let r = &mut s;
    r = String::from("world"); // ❌ mismatched types
    println!("{s}")
}
```

如果将赋值语句改成下面这样，程序能通过编译，但是却无法修改 s 的值。因为此时 r 已经不再指向 s 了，这与程序要求不符。

```rust
fn main() {
    let mut s = String::from("hello");
    let mut r = &mut s;
    r = &mut String::from("world"); // 👎
    println!("{s}") // hello
}
```

正确的改法是下面这样，修改指针指向的变量（C 程序的常见写法）。

```rust
fn main() {
    let mut s = String::from("hello");
    let r = &mut s;
    *r = String::from("world"); // ✅
    println!("{s}") // world
}
```

如果希望在修改之前，先保存旧值，可能会想到如下写法，但是会报错 error\[E0507]: cannot move out of `*r` which is behind a mutable reference

```rust
fn main() {
    let mut s = String::from("hello");
    let r = &mut s;
    let old_value = *r; // ❌ 不能把值从引用中移走，因为 r 之后会指向“空洞”
    *r = String::from("world");
    println!("{s}")
}
```

正确的改法如下

```rust
use std::mem;
fn main() {
    let mut s = String::from("hello");
    let r = &mut s;
    let old_value = mem::replace(r, String::from("world"));
    println!("old_value: {old_value}, s: {s}")
    // old_value: hello, s: world
}
```

---

## 深度解析：

### 1. 类型不匹配的深层原因

第一个例子中：

```rust
let r = &mut s; // r 的类型是 &mut String
r = String::from("world"); // 尝试把 String 赋给 &mut String
```

报错的核心在于：**`r` 是一个“管理者”（指针），而 `String::from` 是一个“实体”（值）。** 你不能把一个实体塞进一个只能装地址的变量里。

### 2. 重新绑定的误区

在第二个例子中，报错虽然消失了，但逻辑断了：

```rust
r = &mut String::from("world");
```

这里发生的事情是：你创建了一个临时的 `String`，让 `r` 指向了它。原先的 `s` 被抛弃了（不再被 `r` 引用）。这在 Rust 中被称为**重新绑定（Rebinding）**。

### 3. 解引用赋值（Dereferencing）

你的第三个例子是正确的“修改原值”的做法：

```rust
*r = String::from("world");
```

通过 `*r`，你告诉 Rust：“我不是要改 `r` 这个指针本身，而是要改 `r` 指向的那块内存里的东西。”

### 4. 关键点：为什么不能 `let old_value = *r`？

- **Move 语义：** `String` 并没有实现 `Copy` 特征。
- **内存空洞：** 如果允许 `let old_value = *r`，那么在这一行执行完、下一行赋值还没开始的中间瞬间，`s` 所占有的内存变成了“无效状态”（所有权被移走了）。如果此时程序崩溃或触发 Drop，Rust 就不知道该释放什么，这会导致内存安全隐患。

### 5. `std::mem::replace` 的魔法

这是 Rust 处理此类问题的标准“手术刀”。它的本质是**原子性的交换**：

1. 把新值塞进去。
2. 把旧值取出来。
3. 整个过程保证了 `s` 在任何时刻都是有效且有值的。

---

## 补充一个进阶技巧

除了 `mem::replace`，在 Rust 1.40 之后，如果你的目的是为了对值进行某种变换后再放回去，还可以使用 `std::mem::take`。 如果 `s` 是 `String`（它实现了 `Default`），你可以这样写：

```rust
let old_value = std::mem::take(r); // r 指向的内容变成了空字符串 ""
*r = String::from("world");
```

这在只需要取出旧值而不在乎中间短暂状态时非常有用。
