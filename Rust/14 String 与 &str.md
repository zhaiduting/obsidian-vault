**它们自身的“元数据”都在栈上，但它们指向的“内容”位置不同。**

你可以把它们想象成两张放在桌面上的**名片**（栈），但名片上记录的**家庭住址**（数据内容）各不相同。

---

### 1. 内存布局深度剖析

我们可以通过下表看清这两个变量在 64 位系统下的本质：

| **变量类型**        | **栈（Stack）上的内容**           | **指向的地址（Data Location）**                      |
| ------------------- | --------------------------------- | ---------------------------------------------------- |
| **`String`**        | **24 字节**：`[指针, 容量, 长度]` | **堆（Heap）**：可以动态增删的空间。                 |
| **`&str` (字面量)** | **16 字节**：`[指针, 长度]`       | **只读数据段（Static）**：编译在二进制文件里的内容。 |
| **`&str` (切片)**   | **16 字节**：`[指针, 长度]`       | **堆（Heap）**：指向某个 `String` 内部的一段区间。   |

---

### 2. 视觉直观对比

想象你运行了这段代码：

```rust
let s1 = String::from("Hello");
let s2 = "World";
```

- **`s1` (String)**：
  - 在**栈**上占 3 个格子（每个 8 字节）：一个指向堆的地址、一个容量值、一个长度值。
  - 在**堆**上开辟了空间存储 `"Hello"`。
- **`s2` (&str)**：
  - 在**栈**上占 2 个格子：一个指向二进制数据区的地址、一个长度值。
  - 它的内容 `"World"` 根本不在堆里，而是在**只读数据区**。

---

### 3. 为什么 `&str` 变量在栈上？

很多人会误以为 `&str` 就是数据本身，其实它只是一个**局部变量**。

```rust
fn main() {
    let s = "Hello"; // s 这个“胖指针”是在 main 函数的栈帧里创建的
} // 函数结束，s 这个 16 字节的指针被弹出栈，但 "Hello" 还在只读区（直到程序结束）
```

**结论：**

- **变量本身**（那几个字节的指针和长度）永远在**栈**上。
- **数据内容**：`String` 的内容在**堆**上；`&'static str` 的内容在**只读数据段**；普通的 `&str` 则指向**它所引用的那个对象**所在的地方。

---

### 避坑小指南

因为 `String` 变量在栈上持有堆的所有权，所以它支持 **Move（移动）语义**：

```rust
let s1 = String::from("hi");
let s2 = s1; // s1 的栈数据拷贝给 s2，s1 失效（所有权转移）

let s3 = "hi";
let s4 = s3; // s3 的栈数据（指针+长度）拷贝给 s4，并且 s3 依然有效（因为只是拷贝了指针）
```

**既然你已经搞清楚了栈和堆的关系，想不想看看当你在 Rust 中对字符串进行“切片操作”时，如果索引没对齐 UTF-8 字符边界会发生什么可怕的事情？**

下一篇 [14.1 切片操作](14.1%20切片操作.md)
