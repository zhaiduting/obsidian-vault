不仅 `Box` 可以自动解引用，`String` 和 `Vec` 也可以。在 Rust 中，`String` 和 `Vec` 实际上都是“管理容器”，它们和 `Box` 一样，底层都拥有一把指向堆内存的“钥匙”。

### 1. `String` 的自动解引用

`String` 实际上是对 `str`（字符串切片）的包装。

- **当你拥有**：`String`
- **它能变身成**：`&str`

**例子：** 许多函数的参数定义为 `&str`（因为它更通用）。由于自动解引用，你可以直接把 `&String` 传给它。

```rust
fn announce(message: &str) {
    println!("公告: {message}");
}

let s = String::from("你好");
announce(&s); // 自动将 &String 转换为 &str
```

---

### 2. `Vec<T>` 的自动解引用

`Vec<T>` 则是对数组切片 `[T]` 的包装。

- **当你拥有**：`Vec<T>`
- **它能变身成**：`&[T]`

**例子：**

```rust
fn print_first_element(slice: &[i32]) {
    println!("第一个是: {}", slice[0]);
}

let v = vec![1, 2, 3];
print_first_element(&v); // 自动将 &Vec<i32> 转换为 &[i32]
```

---

### 3. 它们为什么能变身？（Deref Trait）

这一切的秘密在于一个叫做 `Deref` 的 **Trait**。

- `Box<T>` 实现了 `Deref<Target = T>`。
- `String` 实现了 `Deref<Target = str>`。
- `Vec<T>` 实现了 `Deref<Target = [T]>`。

当你在这些类型上使用 `.` 操作符或者将其作为引用传递给匹配的参数时，Rust 编译器会通过这些 `Deref` 实现，自动帮你完成转换。
