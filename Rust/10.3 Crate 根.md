在 src/bin/、tests/、examples/ 等文件夹里的每一个 `.rs` 文件，在 Cargo 眼中都是一个独立的、平级的 Crate 树根。

这意味着如果你在 `tests/` 目录下放了 10 个 `.rs` 文件，Cargo 实际上会启动 10 次编译器，把它们编译成 10 个独立的二进制文件。

---

### 1. 深度解析：什么是“Crate 根”？

在 `src/` 内部，只有 `main.rs` 和 `lib.rs` 是根，其他文件（如 `utils.rs`）必须被 `mod` 声明才能生存。

但在 `tests/`、`examples/` 和 `src/bin/` 文件夹下，Cargo 遵循**“单文件即根”**的原则：

- 每个文件都是**独立的命名空间**。
- 文件 A 里的全局变量、`use` 声明或私有函数，文件 B 完全看不见。
- 它们彼此之间没有任何父子关系，它们唯一的共同点是都引用了同一个 `lib.rs`。

---

### 2. 动手验证：用 `cargo test` 的输出“抓现行”

这是最直接的验证方法。假设你的 `tests/` 文件夹长这样：

```sh
tests/
├── integration_a.rs
└── integration_b.rs
```

当你运行 `cargo test` 时，仔细观察控制台输出：

```sh
# ... 编译过程 ...
     Running tests/integration_a.rs (target/debug/deps/integration_a-12345)
test test_func_in_a ... ok

     Running tests/integration_b.rs (target/debug/deps/integration_b-67890)
test test_func_in_b ... ok
```

**验证要点：**

- 注意看 **`Running`** 这一行出现了两次。
- 注意括号里的 **`target/debug/deps/...`**。Cargo 为每个文件生成了**不同的哈希值后缀**。这证明了它们是被分别编译成独立的可执行文件的。

---

### 3. 终极验证：代码互访实验

你可以做一个破坏性实验来证明它们是独立的 Crate：

1. 在 `tests/integration_a.rs` 里定义一个 `pub fn helper() {}`。
2. 在 `tests/integration_b.rs` 里尝试调用 `crate::helper();`。

**结果：** 编译器会报错，提示找不到 `helper`。 **结论：** 即使它们在同一个文件夹下，由于它们分别是各自 Crate 的“根（Root）”，它们的 `crate` 关键字指向的是自己，而不是对方。

---

### 4. 为什么 Rust 要这么设计？

这种设计虽然让编译稍微慢了一点（因为要起多个编译器进程），但带来了巨大的好处：

- **真正的隔离**：你为一个特定功能写的测试，绝不会因为不小心修改了另一个测试文件的全局状态而产生“幽灵 Bug”。
- **按需编译**：如果你运行 `cargo run --example demo1`，Cargo 只会编译 `demo1.rs` 及其依赖，而不会理会 `demo2.rs`。
- **灵活部署**：`src/bin/` 下的每个文件都可以作为一个独立的工具发布。

---

### 5. 特殊情况：如果我想要文件夹里的文件“不是根”怎么办？

有时候你想在 `tests/` 里写一些辅助代码（比如模拟数据库的逻辑），供所有测试文件使用。你**不希望**这个辅助文件被当成一个 Crate。

**解决方案：** 使用子文件夹或特定命名。

- **方式 A**：把辅助代码放在 `tests/common/mod.rs` 里。Cargo **不会**自动扫描子文件夹里的文件作为 Crate 根。
- **方式 B**：在 `tests/integration_a.rs` 里通过 `mod common;` 来引用它。

**通过这种方式，`common` 就变成了一个普通的 Module，而不是一个 Crate 根了。**

---

**你现在是不是觉得 Rust 的这种“文件夹即分类，文件即 Crate”的规则非常有秩序感？想不想尝试在 `src/bin/` 下写两个互不干扰的小工具，然后体验一下如何分别运行它们？**
