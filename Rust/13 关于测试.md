```rust
// src/lib.rs

pub fn add(left: u64, right: u64) -> u64 {
    left + right
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        let result = add(2, 2);
        assert_eq!(result, 4);
    }
}
```

### 1. 谁在调用测试函数？

当你执行 `cargo test` 时，背后发生了一系列复杂但有序的操作：

1. **测试执行器 (Test Runner)**：Rust 编译器（`rustc`）在编译时，如果检测到测试模式，会秘密地在你的程序中注入一个**隐形的 `main` 函数**。
2. **反射与发现**：这个隐形 `main` 函数是 Rust 标准库（`std::test`）的一部分。它会扫描所有被标记为 `#[test]` 的函数，并将它们收集到一个列表中。
3. **驱动调用**：当你运行 `cargo test` 时，实际上是在运行这个由 `std::test` 驱动的测试程序。它会根据你的配置（如并发数、过滤条件）逐个调用这些函数。

**简单来说：** 它们是由 **Rust 标准库的测试框架** 调用的，而不是由你自己的 `main.rs` 调用。

---

### 2. `mod tests { ... }` 内的所有函数都会执行吗？

**不一定。** 只有被标记为 **`#[test]`** 的函数才会被执行。

```rust
#[cfg(test)]
mod tests {
    // 这个函数会被执行，因为它有 #[test] 标记
    #[test]
    fn test_path_a() {
        crate::a::a_pub();
    }

    // 这个函数【不会】被执行。它通常作为“辅助工具函数”
    // 供其他测试函数调用
    fn helper_setup() {
        println!("Doing some setup...");
    }
}
```

- **`#[test]`**：告诉测试框架“这是一个独立的测试用例，请运行它”。
- **普通函数**：在测试模块里可以写普通函数，它们不会被框架主动调用，只能被你的测试用例手动调用。

---

### 3. `#[cfg(test)]` 是什么意思？

这是 Rust 的**条件编译**（Conditional Compilation）指令。

- **`cargo build` (正常编译)**：编译器会完全**忽略**这个 `mod tests` 块。它不会出现在最终的可执行文件中，也不会占用任何空间。
- **`cargo test` (测试编译)**：编译器才会把这个块包含进来。

这保证了你的正式发布版本中不会携带任何测试代码。

---

### 4. 为什么要用 `mod tests` 把测试包起来？

虽然你可以把 `#[test]` 随便扔在代码的任何地方，但惯例是写在一个 `mod tests` 块里，原因有三：

1. **整洁性**：把测试逻辑和业务代码分开。
2. **权限优势**：正如我们在“全指南”里提到的，**子模块可以访问父模块的私有内容**。由于 `tests` 是当前模块的子模块，它可以直接测试那些没有 `pub` 的私有函数。
3. **性能**：使用 `#[cfg(test)] mod tests` 可以确保整个模块（包括它引用的测试依赖库）只在测试时存在。

---

### 5. 双料项目中的测试区别

在你的 `mod_atlas` 项目中，运行 `cargo test` 会看到两组测试：

- **单元测试 (Unit Tests)**：写在 `src/lib.rs` 或各子模块内部的代码，通过 `mod tests` 组织。它们能看到模块内部的私有细节。
- **集成测试 (Integration Tests)**：
  - 如果你在 `src/main.rs` 里写测试，它只能测试 `lib.rs` 暴露出来的 `pub` 内容。
  - 如果你在项目根目录创建一个 `tests/` 文件夹，里面的 `.rs` 文件会被视为完全的“外部调用者”。

### 总结

- **谁调用？** Rust 标准库测试框架（隐形 `main`）。
- **谁执行？** 只有带 `#[test]` 的函数。
- **为啥执行？** 因为你开启了 `test` 模式，触发了条件编译。
