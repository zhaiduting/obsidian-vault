---
author:
  - Gemini
source: https://gemini.google.com/app/d40b179800e4d9ed
---

### 基本语法

在 Rust 中，枚举变体后面的圆括号内必须指定它们所携带数据的**类型**。语法如下：

```rust
enum MyEnum {
    VariantName(Type1, Type2, ...),
}
```

举个例子，以下 V4 写法正确，但是 V6 报错。除非定义了一个名为 `abc` 的结构体（`struct`）、枚举（`enum`）、或者其他类型别名，否则编译器不会知道 `abc` 代表什么数据结构，因此会报错。

```rust
enum IpAddr {
    V4(u8, u8, u8, u8), // ✅ u8 是一个有效的基本类型
    V6(abc),            // ❌ abc 在这里必须是一个有效的类型
}
```

### match 匹配

`match` 可以**解构**带参枚举中的数据。

```rust
enum IpAddr {
    V4(u8, u8, u8, u8),
    V6(String),
}

fn handle_ip(ip: IpAddr) {
    match ip {
        IpAddr::V4(a, b, c, d) => {
            println!("✅ 正在处理 IPv4 地址: {}.{}.{}.{}", a, b, c, d);
        }
        IpAddr::V6(_x) => {
            println!("⚠️ 遇到了 IPv6 类型，跳过详细处理。");
        }
    }
}
fn main() {
    let home = IpAddr::V4(127, 0, 0, 1);
    let loopback = IpAddr::V6(String::from("::1"));

    handle_ip(home); // 输出: ✅ 正在处理 IPv4 地址: 127.0.0.1
    handle_ip(loopback); // 输出: ⚠️ 遇到了不关心的 IP 类型，跳过详细处理。
}
```

### 不能使用小数点访问枚举变体

错误示例

```rust
enum State { Working(String) }

fn main(){
    let state = State::Working("Task 1".to_string());
    println!("{}", state.Working) // ❌
}
```

枚举类型不同于结构体，不能使用 `state.Working` 这类写法访问枚举变体的参数。必须先进行模式匹配，再进行变量绑定的方式才能访问。

#### 直接匹配「不可反驳模式」

以下代码中 State 是单变体的枚举类型，枚举变量 state 也必定是 `Working`。此时不需要用 `if let` 或 `match` 来检查，因为没有“失败”的可能。

```rust
enum State { Working(String) }

fn main() {
    let state = State::Working("Task 1".to_string());

    // 可以直接解构赋值，无需 if let
    let State::Working(name) = state;
    println!("{}", name);
}
```

#### 使用 if let 匹配「可反驳模式」

对于多变体的枚举类型，可以使用 if let 或者 match 进行模式匹配。匹配成功后进行变量绑定，通过绑定的变量实现对枚举参数的访问。

```rust
enum State { Working(String), _Idle }

fn main() {
    let state = State::Working("Task 1".to_string());

    // 不能直接解构赋值，错误写法如下
    // let State::Working(name) = state; // ❌

    // 方式一：if let 匹配 ✅
    // “如果是 Working 状态，请把里面的值绑定到变量 name 上”
    if let State::Working(name) = state {
        // 在此作用域内访问 name
        println!("{}", name);
    }
}
```

#### 使用 if let 匹配「可反驳模式」

在 Rust 1.65+ 版本中，还可以使用新增的 `let-else` 语句进行模式匹配。

```rust
enum State { Working(String), _Idle }

fn main() {
    let state = State::Working("Task 1".to_string());

    // 不能直接解构赋值，错误写法如下
    // let State::Working(name) = state; // ❌

    // 方式二：let-else 匹配 ✅
    let State::Working(name) = state else{
        panic!("不是 Working 状态！");
    };
    println!("正在处理 {}", name);
}
```

### 结构体变体

之前的写法 `Working(String)` 是**元组变体**。如果希望它看起来更像一个对象，可以使用**结构体变体**，但访问它依然需要解构。

```rust
enum State {
    Working { name: String }, // 注意这里用了大括号
    _Idle
}

fn main() {
    let state = State::Working{ name:"Task 1".to_string() };

    // 方式一：if let 匹配 ✅
    // 注意解构赋值用 Working{name} 而不是 Working(name)
    if let State::Working{name} = &state {
        println!("{}", name);
    }

    // 方式二：let-else 匹配 ✅
    let State::Working{name} = state else{
        panic!("不是 Working 状态！");
    };
    println!("正在处理 {}", name);
}
```

结构体变体与元组变体的用法非常相似，但也有显著不同的地方

- 结构体用 `Working { name: String }` 元组用 `Working(String)`
- 结构体变体在解构赋值的时候，必须使用结构体中实际存在的字段名，而元组却可以使用随意命名的变量。也就是说 `if let State::Working(name2) = state {...}` 这样的 name2 变量完全可以；但是 `if let State::Working{name2} = ...` 却不可以！因为结构体中不存在 name2 字段。

注意 `if let State::Working{name} = &state {...}` 中多了一个 & 符号，原因在于 Rust 具有[所有权（Ownership）与移动（Move）语义](./7%20所有权（Ownership）与移动（Move）语义.md)的概念。
