---
author:
  - Gemini
source: https://gemini.google.com/app/d40b179800e4d9ed
---

### 基本语法

在 Rust 中，枚举变体后面的圆括号内必须指定它们所携带数据的**类型**。语法如下：

```rust
enum MyEnum {
    VariantName(Type1, Type2, ...),
}
```

举个例子，以下 V4 写法正确，但是 V6 报错。除非定义了一个名为 `abc` 的结构体（`struct`）、枚举（`enum`）、或者其他类型别名，否则编译器不会知道 `abc` 代表什么数据结构，因此会报错。

```rust
enum IpAddr {
    V4(u8, u8, u8, u8), // ✅ u8 是一个有效的基本类型
    V6(abc),            // ❌ abc 在这里必须是一个有效的类型
}
```

### match 匹配

`match` 可以**解构**带参枚举中的数据。

```rust
enum IpAddr {
    V4(u8, u8, u8, u8),
    V6(String),
}

fn handle_ip(ip: IpAddr) {
    match ip {
        IpAddr::V4(a, b, c, d) => {
            println!("✅ 正在处理 IPv4 地址: {}.{}.{}.{}", a, b, c, d);
        }
        IpAddr::V6(_x) => {
            println!("⚠️ 遇到了 IPv6 类型，跳过详细处理。");
        }
    }
}
fn main() {
    let home = IpAddr::V4(127, 0, 0, 1);
    let loopback = IpAddr::V6(String::from("::1"));

    handle_ip(home); // 输出: ✅ 正在处理 IPv4 地址: 127.0.0.1
    handle_ip(loopback); // 输出: ⚠️ 遇到了不关心的 IP 类型，跳过详细处理。
}
```

### 不能使用小数点访问枚举变体

错误示例

```rust
enum State { Working(String) }

fn main(){
    let state = State::Working("Task 1".to_string());
    println!("{}", state.Working) // ❌
}
```

假设能写 `state.Working`，那万一当前的 `state` 实际上是 `Idle` 呢？此时 `Working` 里的字符串根本不存在。为了保证内存安全，Rust 强制你必须先检查（匹配）当前到底属于哪个变体，只有确定了是某个变体，它才允许你访问内部的数据。这从根本上杜绝了访问无效数据的可能性。

#### 直接匹配「不可反驳模式」

以下代码中 State 是单变体的枚举类型，枚举变量 state 也必定是 `Working`。此时不需要用 `if let` 或 `match` 来检查，因为没有“失败”的可能。

```rust
enum State { Working(String) }

fn main() {
    let state = State::Working("Task 1".to_string());

    // 可以直接解构赋值，无需 if let
    let State::Working(name) = state;
    println!("{}", name);
}
```

#### 使用 if let 匹配「可反驳模式」

对于多变体的枚举类型，需要使用 if let 或者 match 进行匹配。

```rust
enum State { Working(String), _Idle }

fn main() {
    let state = State::Working("Task 1".to_string());

    // “如果是 Working 状态，请把里面的值绑定到变量 name 上”
    if let State::Working(name) = state {
        // 在此作用域内访问 name
        println!("{}", name);
    }
}
```
