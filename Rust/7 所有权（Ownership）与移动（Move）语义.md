---
source: https://gemini.google.com/app/738e1d7442f6bde4
author:
  - Gemini
created: 2026-02-03
tags:
  - clippings
---

在 Rust 的世界里， **所有权（Ownership）** 确实是那道区分“入门”与“精通”的分水岭。这套机制让 Rust 无需垃圾回收（GC）就能保证内存安全，但也常让刚从 Python 或 Java 转向 Rust 的开发者感到“处处碰壁”。

我们可以把所有权机制看作是一套严格的 **内存资源管理法律** 。

---

## 1\. 所有权的三大原则

Rust 的所有权规则非常简洁，编译器（借用检查器）会像交警一样盯着你是否违反了它们：

1. **每一个值都有一个变量被称为其“所有者”（Owner）。**
2. **同一时间内，值只能有一个所有者。**
3. **当所有者离开作用域（Scope）时，值会被自动销毁（Drop）。**

---

## 2\. 移动（Move）语义：接力棒的传递

在其他语言中，赋值通常意味着“复制”或“增加引用计数”。但在 Rust 中，对于存储在堆（Heap）上的数据（如 `String` 或 `Vec` ），赋值默认是 **移动（Move）** 。

### 核心逻辑

当你把 `s1` 赋值给 `s2` 时，Rust 不会去复制堆上的数据（那样太慢），也不会让两个变量同时指向它（那样会导致两次释放内存的危险）。它会直接 **把所有权从 `s1` 转交给 `s2`** ，并立即使 `s1` 失效。

### 示例代码：

```rust
fn main() {
    let s1 = String::from("hello"); // s1 拥有堆上的字符串
    let s2 = s1; // 发生所有权移动（Move）

    // println!("{}", s1); // ❌ 报错！s1 已经不再拥有该数据，它成了“空壳”
    println!("{}", s2);    // ✅ 正常输出
}
```

---

## 3\. 复制（Copy）语义：特例

并不是所有东西都会移动。对于存储在 **栈（Stack）** 上的简单数据类型（如整数、布尔值、浮点数），它们实现了 `Copy` 特征。

在这种情况下，赋值是真正的“克隆”，原变量依然可用。

```rust
let x = 5;
let y = x; // 发生了复制（Copy）
println!("x: {}, y: {}", x, y); // ✅ 两者都可用
```

---

## 4\. 为什么要这么设计？

这种设计解决了 C/C++ 中最头疼的几个问题：

- **悬垂指针（Dangling Pointers）：** 确保数据不会在还有人使用时被释放。
- **二次释放（Double Free）：** 因为只有一个所有者，所以只会释放一次。
- **零成本抽象：** 这种检查是在 **编译期** 完成的，运行时没有任何性能开销。

---

## 5\. 如何“拿回”所有权？

如果你不想移动所有权，通常有两种应对方案：

### A. 克隆（Clone）

如果你确实需要两份独立的数据，可以手动调用 `.clone()` 。这会复制堆上的数据。

```rust
let s3 = s2.clone(); // s2 和 s3 现在各自拥有一份 "hello"
```

### B. 借用（Borrowing）

这是最常用的方式—— **引用（&）** 。你把东西借给别人用，但你依然是所有者。

```rust
fn calculate_length(s: &String) -> usize { // 接收引用
    s.len()
} // 这里 s 离开作用域，但因为它只是借来的，所以不会销毁原数据
```

---

## 总结

- **移动（Move）** 是为了内存安全：一次只能有一个负责人。
- **作用域结束即销毁** ：解决了内存泄漏。
- **编译期检查** ：把运行时的崩溃风险提前到了写代码的时候。

这就是 Rust 的“成人礼”：它强迫你思考每一块内存在何时创建、由谁持有、在何时销毁。一旦掌握，你编写的代码将具备极高的稳定性和性能。

## 相关笔记

- [7.1 Copy 与 Move 的对比](7.1%20Copy%20与%20Move%20的对比.md)
- [7.2 println 宏的语义](./7.2%20println%20宏的语义.md)
- [7.3 Borrowing 的可变与不可变](7.3%20Borrowing%20的可变与不可变.md)
- [7.4 Borrowing 的奇怪问题](7.4%20Borrowing%20的奇怪问题.md)
