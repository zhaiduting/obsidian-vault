---
source: https://gemini.google.com/app/738e1d7442f6bde4
author:
  - Gemini
created: 2026-02-03
tags:
  - clippings
---

在 Rust 的世界里， **所有权（Ownership）** 确实是那道区分“入门”与“精通”的分水岭。这套机制让 Rust 无需垃圾回收（GC）就能保证内存安全，但也常让刚从 Python 或 Java 转向 Rust 的开发者感到“处处碰壁”。

我们可以把所有权机制看作是一套严格的 **内存资源管理法律** 。

---

## 1\. 所有权的三大原则

Rust 的所有权规则非常简洁，编译器（借用检查器）会像交警一样盯着你是否违反了它们：

1. **每一个值都有一个变量被称为其“所有者”（Owner）。**
2. **同一时间内，值只能有一个所有者。**
3. **当所有者离开作用域（Scope）时，值会被自动销毁（Drop）。**

---

## 2\. 移动（Move）语义：接力棒的传递

在其他语言中，赋值通常意味着“复制”或“增加引用计数”。但在 Rust 中，对于存储在堆（Heap）上的数据（如 `String` 或 `Vec` ），赋值默认是 **移动（Move）** 。

### 核心逻辑

当你把 `s1` 赋值给 `s2` 时，Rust 不会去复制堆上的数据（那样太慢），也不会让两个变量同时指向它（那样会导致两次释放内存的危险）。它会直接 **把所有权从 `s1` 转交给 `s2`** ，并立即使 `s1` 失效。

### 示例代码：

```rust
fn main() {
    let s1 = String::from("hello"); // s1 拥有堆上的字符串
    let s2 = s1; // 发生所有权移动（Move）

    // println!("{}", s1); // ❌ 报错！s1 已经不再拥有该数据，它成了“空壳”
    println!("{}", s2);    // ✅ 正常输出
}
```

---

## 3\. 复制（Copy）语义：特例

并不是所有东西都会移动。对于存储在 **栈（Stack）** 上的简单数据类型（如整数、布尔值、浮点数），它们实现了 `Copy` 特征。

在这种情况下，赋值是真正的“克隆”，原变量依然可用。

```rust
let x = 5;
let y = x; // 发生了复制（Copy）
println!("x: {}, y: {}", x, y); // ✅ 两者都可用
```

---

## 4\. 为什么要这么设计？

这种设计解决了 C/C++ 中最头疼的几个问题：

- **悬垂指针（Dangling Pointers）：** 确保数据不会在还有人使用时被释放。
- **二次释放（Double Free）：** 因为只有一个所有者，所以只会释放一次。
- **零成本抽象：** 这种检查是在 **编译期** 完成的，运行时没有任何性能开销。

---

## 5\. 如何“拿回”所有权？

如果你不想移动所有权，通常有两种应对方案：

### A. 克隆（Clone）

如果你确实需要两份独立的数据，可以手动调用 `.clone()` 。这会复制堆上的数据。

```rust
let s3 = s2.clone(); // s2 和 s3 现在各自拥有一份 "hello"
```

### B. 借用（Borrowing）

这是最常用的方式—— **引用（&）** 。你把东西借给别人用，但你依然是所有者。

```rust
fn calculate_length(s: &String) -> usize { // 接收引用
    s.len()
} // 这里 s 离开作用域，但因为它只是借来的，所以不会销毁原数据
```

---

## 总结

- **移动（Move）** 是为了内存安全：一次只能有一个负责人。
- **作用域结束即销毁** ：解决了内存泄漏。
- **编译期检查** ：把运行时的崩溃风险提前到了写代码的时候。

这就是 Rust 的“成人礼”：它强迫你思考每一块内存在何时创建、由谁持有、在何时销毁。一旦掌握，你编写的代码将具备极高的稳定性和性能。

---

## 以函数的参数为例说明

错误代码如下

```rust
let s = "Hello".to_string();
fn calculate_length(s: String) -> usize {
    s.len()
}
println!("s = {}, length = {}", s, calculate_length(s))
```

报错信息为 `error[E0505]: cannot move out of `s` because it is borrowed`

### 1\. 先了解 println! 宏

`println!` 宏的设计初衷是让你方便地打印数据，而不是让你在打印时丢掉数据的所有权。
`println!` 宏在展开代码时，会自动为参数加上取地址符 `&`。
`println!("{}", s)` 与 `println!("{}", &s)` 实际效果是一样的。

- **当你传 `s` 时：** 宏展开后，它实际上是通过引用来访问 `s` 的。这被称为“自动借用”。
- **当你传 `&s` 时：** 你显式地传递了一个引用。对于 `println!` 来说，它接收到的就是一个引用的引用（`&&String`），而 Rust 的 `Display` 特征（Trait）可以自动处理这种多层引用（解引用强制转换）。

**结论：** 无论你加不加 `&`，`println!` 最终都是在**不获取所有权**的情况下读取数据。

### 2\. 再看 calculate_length 函数

函数 `fn calculate_length(s: String)` 签名的意思是： **“我需要接管这个字符串的所有权”** 。

- 执行 `calculate_length(s)` 时，变量 `s` 的所有权被移动（Move）到了函数内部的形参 `s` 中。
- 当函数执行完毕，函数内部的 `s` 离开作用域，该字符串占用的内存会被立即释放（Drop）。
- 此时，外部作用域的 `s` 已经变成了 **无效的“空壳”** 。

⚠️ 总而言之在 Rust 中，如果你看到一个函数接收 `String` 而不是 `&String` ，请务必警惕—— **这通常意味着调用结束后，原变量就“死”了。**

### 2\. 分析 println! 报错原因

在处理 `println!("...", s, calculate_length(s))` 时，编译器会分析这一行中所有变量的状态：

1. **词法扫描**：编译器扫描这一行，发现 `println!` 宏需要对变量 `s` 进行一次**不可变借用**（为了打印第一个 `{}`）。
2. **划定借用范围**：这个借用的生命周期（Lifetime）必须覆盖整个 `println!` 语句的执行过程。
3. **发现冲突**：在同一个语句中，编译器看到了 `calculate_length(s)`。由于这个函数接收的是 `String`（所有权类型），它要求立即执行 **Move** 操作。
4. **抛出错误**：编译器判定——“在 `s` 被借用的期间，你试图移走它”。这就触发了 `E0505` 错误。

⚠️ 在 Rust 看来，只要一个变量被借用了，它就进入了“冻结”状态。在冻结期间：

- 不能被**修改**（如果是不可变借用）。
- 绝对不能被**移动**（Move）。

### 3\. 如果先移走，后借用会怎样？

```rust
// 原先代码，先借后移
// error[E0505]: cannot move out of `s` because it is borrowed
println!("s = {}, length = {}", s, calculate_length(s))

// 改成下面这样，先移后借
// error[E0382]: borrow of moved value: `s`
println!("length = {}, s = {}", calculate_length(s), s)
```

这个更容易理解：你无法借用一个已被移走的 s

### 4\. 修正方案

如果你既想得到长度，又想在之后继续使用字符串，有三种办法：

#### 方案 A：借用（最推荐）

使用引用 `&String` 或 `&str` 。这是 Rust 的日常操作，像借书看一样，看完还回来。

```rust
fn calculate_length(s: &String) -> usize {
    s.len()
}
// 调用时加 &，表示只借不移
println!("s = {}, length = {}", s, calculate_length(&s));
```

#### 方案 B：克隆（最暴力）

如果你不在乎性能开销，可以送一个副本过去。

```rust
// 送一个分身过去，本体 s 依然安全
println!("s = {}, length = {}", s, calculate_length(s.clone()));
```

#### 方案 C：把所有权还回来（最原始）

函数不仅返回长度，还把字符串原样退回。

```rust
fn calculate_length(s: String) -> (String, usize) {
    let len = s.len();
    (s, len) // 返回一个元组，把所有权还回去
}
```

这是一种相对麻烦的改法，main() 函数也要做相应调整

```rust
fn main() {
    let s = String::from("Hello");

    // 1. 调用函数，s 的所有权移入函数
    // 2. 函数返回一个元组 (String, usize)
    // 3. 通过模式匹配，将所有权重新绑定给新的变量 s（变量遮蔽）
    let (s, len) = calculate_length(s);

    // 现在 s 重新拥有了所有权，可以安全打印
    println!("s = {}, length = {}", s, len);
}
```

### 方案对比

虽然“还回所有权”的方法可行，但在 Rust 中， **90% 的场景下我们都会选择“借用（&String）”** ，因为手动还所有权显得太啰嗦了：

| 方法             | 代码复杂度        | 内存开销      | 推荐度     |
| ---------------- | ----------------- | ------------- | ---------- |
| **元组返回**     | 高 (需要重新绑定) | 低            | ⭐         |
| **克隆 (Clone)** | 低                | 高 (复制内存) | ⭐⭐       |
| **借用 (&)**     | **极低**          | **极低**      | ⭐⭐⭐⭐⭐ |
