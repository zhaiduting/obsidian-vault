### 一、 物理结构：文件即模块

Rust 建立了文件系统与逻辑代码的映射关系：

- **根节点**：项目的起点永远是 `src/lib.rs` (库) 或 `src/main.rs` (可执行程序)。
- **节点声明**：文件 `a.rs` 定义了模块 `a`。如果 `a` 拥有子模块，则创建一个**同名文件夹** `a/` 来存放子文件。
- **挂载规则**：要在项目中使用 `a.rs`，必须在其父模块（通常是 `lib.rs`）中使用 `mod a;` 进行挂载。

### 二、 准入权限：谁能访问我？

可见性决定了代码的边界，遵循“向下限制，向上开放”原则：

- **私有 (默认)**：仅限**当前模块**及其**直接子模块**可见。
  > _注：这打破了“父看子”的直觉——父模块默认看不见子模块内部，除非加 `pub`。_
- **项目内可见 (`pub(crate)`)**：在当前整个工程（Crate）内任何地方都可访问，但不对外（作为第三方库时）暴露。
- **完全公开 (`pub`)**：只要能搜到路径，任何人（包括外部依赖）都能访问。

### 三、 路径导航：如何找到它？

路径解析就像 GPS 坐标，分为绝对和相对两种：

- **起点定义**：
  - `crate::`：**绝对路径**。永远从根（`lib.rs` 或 `main.rs`）出发。最稳妥，推荐首选。
  - `super::`：**相对路径**。向父级跳一级。适用于子模块调用父级工具函数。
  - `self::`：**相对路径**。当前模块，常用于 `use` 语句合并路径。
- **同级互访**：
  - 如果是兄弟模块，需通过 `crate::兄弟名` 或 `super::兄弟名` 访问。

---

### 💡 综合对比表

| **维度**    | **情况**    | **动作 / 关键字**         | **核心备注**             |
| --------- | --------- | -------------------- | -------------------- |
| **层级组织**  | 声明子模块     | `mod sub;`           | 在父模块文件中写，对应 `sub.rs` |
| **可见性**   | 允许父级/兄弟访问 | `pub` 或 `pub(crate)` | 没标就不给看（无论路径多对）       |
| **向上导航**  | 调用父级/祖先   | `super::`            | 逐级回退，类似 `../`        |
| **全域导航**  | 调用任意位置    | `crate::a::b`        | 只要是 `pub` 就能一通到底     |
| **上下文感应** | 获取当前位置    | `module_path!()`     | 编译期确定，用于调试和日志        |

---

### 🎓 最终的一句话口诀

**“声明挂父辈，访问看 `pub`，回退找 `super`，全局搜 `crate`。”**

如果你把这套规则应用到项目开发中，你会发现 `crate::` 路径配合 `pub(crate)` 是最能平衡“安全性”与“调用便利性”的做法。
